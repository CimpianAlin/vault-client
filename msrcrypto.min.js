var nodeJsSupport=typeof module!=="undefined"&&this.module!==module;if(nodeJsSupport){var window=global}var msrCryptoVersion="1.4";var msrCrypto=msrCrypto||function(){"use strict";var operations={};operations.register=function(operationType,algorithmName,functionToCall){if(!operations[operationType]){operations[operationType]={}}var op=operations[operationType];if(!op[algorithmName]){op[algorithmName]=functionToCall}};operations.exists=function(operationType,algorithmName){if(!operations[operationType]){return false}return operations[operationType][algorithmName]?true:false};var scriptUrl=function(){if(typeof document!=="undefined"){try{throw new Error}catch(e){if(e.stack){var match=/\w+:\/\/(.+?\/)*.+\.js/.exec(e.stack);return match&&match.length>0?match[0]:null}}}else if(typeof self!=="undefined"){return self.location.href}return null}();var fprngEntropyProvided=false;var webWorkerSupport=typeof Worker!=="undefined";var runningInWorkerInstance=typeof importScripts!=="undefined";var typedArraySupport=typeof Uint8Array!=="undefined";var setterSupport=function(){try{Object.defineProperty({},"oncomplete",{});return true}catch(ex){return false}}();var asyncMode=webWorkerSupport;var createProperty=function(parentObject,propertyName,initialValue,getterFunction,setterFunction){if(!setterSupport){parentObject[propertyName]=initialValue;return}var setGet={};getterFunction&&(setGet.get=getterFunction);setterFunction&&(setGet.set=setterFunction);Object.defineProperty(parentObject,propertyName,setGet)};var msrcryptoHashFunctions={};var msrcryptoUtilities=function(){var encodingChars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var btoaSupport=typeof btoa!=="undefined";function toBase64(data,base64Url){var output="";if(!base64Url){base64Url=false}if(data.pop||data.subarray){data=String.fromCharCode.apply(null,data)}if(btoaSupport){output=btoa(data)}else{var char1,char2,char3,enc1,enc2,enc3,enc4;var i;for(i=0;i<data.length;i+=3){char1=data.charCodeAt(i);char2=data.charCodeAt(i+1);char3=data.charCodeAt(i+2);enc1=char1>>2;enc2=(char1&3)<<4|char2>>4;enc3=(char2&15)<<2|char3>>6;enc4=char3&63;if(isNaN(char2)){enc3=enc4=64}else if(isNaN(char3)){enc4=64}output=output+encodingChars.charAt(enc1)+encodingChars.charAt(enc2)+encodingChars.charAt(enc3)+encodingChars.charAt(enc4)}}if(base64Url){return output.replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}return output}function base64ToString(encodedString){if(btoaSupport){encodedString=encodedString.replace(/-/g,"+").replace(/_/g,"/");while(encodedString.length%4!==0){encodedString+="="}return atob(encodedString)}return String.fromCharCode.apply(null,base64ToBytes(encodedString))}function base64ToBytes(encodedString){encodedString=encodedString.replace(/-/g,"+").replace(/_/g,"/");while(encodedString.length%4!==0){encodedString+="="}var output=[];var char1,char2,char3;var enc1,enc2,enc3,enc4;var i;encodedString=encodedString.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(i=0;i<encodedString.length;i+=4){enc1=encodingChars.indexOf(encodedString.charAt(i));enc2=encodingChars.indexOf(encodedString.charAt(i+1));enc3=encodingChars.indexOf(encodedString.charAt(i+2));enc4=encodingChars.indexOf(encodedString.charAt(i+3));char1=enc1<<2|enc2>>4;char2=(enc2&15)<<4|enc3>>2;char3=(enc3&3)<<6|enc4;output.push(char1);if(enc3!==64){output.push(char2)}if(enc4!==64){output.push(char3)}}return output}function getObjectType(object){return Object.prototype.toString.call(object).slice(8,-1)}function bytesToHexString(bytes,separate){var result="";if(typeof separate==="undefined"){separate=false}for(var i=0;i<bytes.length;i++){if(separate&&i%4===0&&i!==0){result+="-"}var hexval=bytes[i].toString(16).toUpperCase();if(hexval.length===1){result+="0"}result+=hexval}return result}function bytesToInt32(bytes,index){index=index||0;return bytes[index]<<24|bytes[index+1]<<16|bytes[index+2]<<8|bytes[index+3]}function stringToBytes(messageString){var bytes=new Array(messageString.length);for(var i=0;i<bytes.length;i++){bytes[i]=messageString.charCodeAt(i)}return bytes}function hexToBytesArray(hexString){hexString=hexString.replace(/\-/g,"");var result=[];while(hexString.length>=2){result.push(parseInt(hexString.substring(0,2),16));hexString=hexString.substring(2,hexString.length)}return result}function clone(object){var newObject={};for(var propertyName in object){if(object.hasOwnProperty(propertyName)){newObject[propertyName]=object[propertyName]}}return newObject}function unpackData(base64String,arraySize,toUint32s){var bytes=base64ToBytes(base64String),data=[],i;if(isNaN(arraySize)){return bytes}else{for(i=0;i<bytes.length;i+=arraySize){data.push(bytes.slice(i,i+arraySize))}}if(toUint32s){for(i=0;i<data.length;i++){data[i]=(data[i][0]<<24)+(data[i][1]<<16)+(data[i][2]<<8)+data[i][3]}}return data}function int32ToBytes(int32){return[int32>>>24&255,int32>>>16&255,int32>>>8&255,int32&255]}function int32ArrayToBytes(int32Array){var result=[];for(var i=0;i<int32Array.length;i++){result=result.concat(int32ToBytes(int32Array[i]))}return result}function xorVectors(a,b){var length=Math.min(a.length,b.length),res=new Array(length);for(var i=0;i<length;i+=1){res[i]=a[i]^b[i]}return res}function getVector(length,fillValue){fillValue||(fillValue=0);var res=new Array(length);for(var i=0;i<length;i+=1){res[i]=fillValue}return res}function toArray(typedArray){if(!typedArray){return[]}if(typedArray.pop){return typedArray}if(typedArray.isView){typedArray=Uint8Array(typedArray)}return typedArray.length===1?[typedArray[0]]:Array.apply(null,typedArray)}function padEnd(array,value,finalLength){while(array.length<finalLength){array.push(value)}return array}function padFront(array,value,finalLength){while(array.length<finalLength){array.unshift(value)}return array}function arraysEqual(array1,array2){var result=true;if(array1.length!==array2.length){result=false}for(var i=0;i<array1.length;i++){if(array1[i]!==array2[i]){result=false}}return result}function verifyByteArray(array){if(getObjectType(array)!=="Array"){return false}var element;for(var i=0;i<array.length;i++){element=array[i];if(isNaN(element)||element<0||element>255){return false}}return true}return{toBase64:toBase64,base64ToString:base64ToString,base64ToBytes:base64ToBytes,getObjectType:getObjectType,bytesToHexString:bytesToHexString,bytesToInt32:bytesToInt32,stringToBytes:stringToBytes,unpackData:unpackData,hexToBytesArray:hexToBytesArray,int32ToBytes:int32ToBytes,int32ArrayToBytes:int32ArrayToBytes,toArray:toArray,arraysEqual:arraysEqual,clone:clone,xorVectors:xorVectors,padEnd:padEnd,padFront:padFront,getVector:getVector,verifyByteArray:verifyByteArray}}();var msrcryptoWorker=function(){function returnResult(result){if(runningInWorkerInstance){self.postMessage(result)}return result}return{jsCryptoRunner:function(e){var operation=e.data.operationType;var result;if(!operations.exists(operation,e.data.algorithm.name)){throw new Error("unregistered algorithm.")}var func=operations[operation][e.data.algorithm.name];var p=e.data;if(p.operationSubType==="process"){func(p);result=returnResult({type:"process"})}else{result=returnResult(func(p))}return result}}}();if(runningInWorkerInstance){self.onmessage=function(e){if(e.data.prngSeed){var entropy=e.data.prngSeed;msrcryptoPseudoRandom.init(entropy);return}msrcryptoWorker.jsCryptoRunner(e)}}var msrcryptoJwk=function(){var utils=msrcryptoUtilities;function stringToArray(stringData){var result=[];for(var i=0;i<stringData.length;i++){result[i]=stringData.charCodeAt(i)}if(result[result.length-1]===0){result.pop()}return result}function getKeyType(keyHandle){var algType=keyHandle.algorithm.name.slice(0,3).toLowerCase();if(algType==="rsa"){return"RSA"}if(algType==="ecd"){return"EC"}return"oct"}var algorithmMap={hmac:function(algorithm){return"HS"+algorithm.hash.name.substring(algorithm.hash.name.indexOf("-")+1)},"aes-cbc":function(algorithm){return"A"+algorithm.length.toString()+"CBC"},"aes-gcm":function(algorithm){return"A"+algorithm.length.toString()+"GCM"},"rsaes-pkcs1-v1_5":function(algorithm){return"RSA1_5"},"rsassa-pkcs1-v1_5":function(algorithm){return"RS"+algorithm.hash.name.substring(algorithm.hash.name.indexOf("-")+1)},"rsa-oaep":function(algorithm){return"RS-OAEP-"+algorithm.hash.name.substring(algorithm.hash.name.indexOf("-")+1)},"rsa-pss":function(algorithm){return"PS-"+algorithm.hash.name.substring(algorithm.hash.name.indexOf("-")+1)},ecdsa:function(algorithm){return"EC-"+algorithm.namedCurve.substring(algorithm.namedCurve.indexOf("-")+1)}};function keyToJwk(keyHandle,keyData){var key={};key.kty=getKeyType(keyHandle);key.ext=keyHandle.extractable;key.alg=algorithmMap[keyHandle.algorithm.name.toLowerCase()](keyHandle.algorithm);key.key_ops=keyHandle.keyUsage;if(keyData.pop){key.k=utils.toBase64(keyData,true)}else{for(var property in keyData){if(keyData[property].pop){key[property]=utils.toBase64(keyData[property],true)}}}if(keyHandle.algorithm.namedCurve){key["crv"]=keyHandle.algorithm.namedCurve}return key}function keyToJwkOld(keyHandle,keyData){var key={};key.kty=getKeyType(keyHandle);key.extractable=keyHandle.extractable;if(keyData.pop){key.k=utils.toBase64(keyData,true)}else{for(var property in keyData){if(keyData[property].pop){key[property]=utils.toBase64(keyData[property],true)}}}if(keyHandle.algorithm.namedCurve){key["crv"]=keyHandle.algorithm.namedCurve}var stringData=JSON.stringify(key,null,"	");return stringToArray(stringData)}function jwkToKey(keyData,algorithm,propsToArray){var jsonKeyObject=JSON.parse(JSON.stringify(keyData));for(var i=0;i<propsToArray.length;i+=1){var propValue=jsonKeyObject[propsToArray[i]];if(propValue){jsonKeyObject[propsToArray[i]]=utils.base64ToBytes(propValue)}}return jsonKeyObject}return{keyToJwkOld:keyToJwkOld,keyToJwk:keyToJwk,jwkToKey:jwkToKey}}();function msrcryptoMath(){var DIGIT_BITS=24;var DIGIT_NUM_BYTES=Math.floor(DIGIT_BITS/8);var DIGIT_MASK=(1<<DIGIT_BITS)-1;var DIGIT_BASE=1<<DIGIT_BITS;var DIGIT_MAX=DIGIT_MASK;var DIGIT_SCALER=[1,256];for(var i=2;i<=DIGIT_NUM_BYTES;i++){DIGIT_SCALER[i]=DIGIT_SCALER[i-1]*256}var Zero=[0];var One=[1];function createArray(parameter){var i,array=null;if(!arguments.length||typeof arguments[0]==="number"){array=new Array(parameter);for(i=0;i<parameter;i+=1){array[i]=0}}else if(typeof arguments[0]==="object"){array=new Array(parameter.length);for(i=0;i<parameter.length;i+=1){array[i]=parameter[i]}}return array}function swapEndianness(bytes){var out=new Array(bytes.length);var i=0;while(i<bytes.length){out[i]=bytes[bytes.length-i-1];i+=1}return out}function stringToDigits(number,radix){number=number.replace(/^\s+|\s+$/g,"");var num=[0];var buffer=[0];radix=radix||10;for(var i=0;i<number.length;i+=1){var char=parseInt(number[i],radix);if(isNaN(char)){throw new Error("Failed to convert string to integer in radix "+radix.toString())}multiply(num,radix,buffer);add(buffer,[char],num);normalizeDigitArray(num)}return num}function digitsToString(digits,radix){radix=radix||10;if(DIGIT_BASE<=radix){throw new Error("DIGIT_BASE is smaller than RADIX; cannot convert.")}var wordLength=digits.length;var quotient=[];var remainder=[];var temp1=[];var temp2=[];var divisor=[];var a=[];var i;var sb="";var pad="0";divisor[0]=radix;while(Math.floor(DIGIT_BASE/divisor[0])>=radix){divisor[0]=divisor[0]*radix;pad=pad.concat("0")}for(i=0;i<wordLength;i+=1){a[i]=digits[i]}do{var allZeros=true;for(i=0;i<a.length;i+=1){if(a[i]!==0){allZeros=false;break}}if(allZeros){break}divRem(a,divisor,quotient,remainder,temp1,temp2);normalizeDigitArray(quotient,a.length,true);var newDigits=remainder[0].toString(radix);sb=pad.substring(0,pad.length-newDigits.length)+newDigits+sb;var swap=a;a=quotient;quotient=swap}while(true);while(sb.length!==0&&sb[0]==="0"){sb=sb.substring(1,sb.length)}if(sb.length===0){sb="0"}return sb}function powerOfTwo(i){var requiredBytes=Math.ceil((i+1)/8);var out=createArray(requiredBytes);out[0]=Math.pow(2,i%8);return out}function computeBitArray(bytes){var out=createArray(bytes.length*8);var bitLength=0;var i=bytes.length-1;while(i>=0){var j=0;while(j<8){var mask=1<<j;var bit=(bytes[i]&mask)===mask?1:0;var thisBitIndex=8*(bytes.length-i-1)+j;if(bit===1){bitLength=thisBitIndex+1}out[thisBitIndex]=bit;j+=1}i--}return out.slice(0,bitLength)}function bitScanForward(value){var mask=DIGIT_BASE>>>1;var index=DIGIT_BITS;while(index-- >0){if((value&mask)===mask){break}mask=mask>>>1}return index}function highestSetBit(bytes){var i=0;var bitLength=0;while(i<bytes.length){if(bitLength===0){var j=7;while(j>=0&&bitLength===0){var mask=1<<j;if((bytes[i]&mask)===mask){bitLength=j+1}j--}}else{bitLength+=8}i+=1}return bitLength}function fixedWindowRecode(digits,windowSize,t){digits=digits.slice();var recodedDigits=[],windowSizeBits=Math.pow(2,windowSize),windowSizeMinus1Bits=Math.pow(2,windowSize-1);for(var i=0;i<t;i++){recodedDigits[i]=digits[0]%windowSizeBits-windowSizeMinus1Bits;digits[0]=digits[0]-recodedDigits[i];cryptoMath.shiftRight(digits,digits,windowSize-1)}recodedDigits[i]=digits[0];return recodedDigits}function fetchBits(digits,startBit,count){var startDigit=Math.floor(startBit/cryptoMath.DIGIT_BITS);var endDigit=startDigit+1;var shiftRight=startBit%cryptoMath.DIGIT_BITS;var shiftLeft=cryptoMath.DIGIT_BITS-shiftRight;var bits=digits[startDigit]>>>shiftRight|digits[endDigit]<<shiftLeft;return bits&cryptoMath.DIGIT_MASK>>>cryptoMath.DIGIT_BITS-count}function fetchBits2(digits,startBit,count){var startDigit=Math.floor(startBit/DIGIT_BITS),shiftRight=startBit%DIGIT_BITS;return digits[startDigit]>>>shiftRight|digits[startDigit+1]<<DIGIT_BITS-shiftRight&DIGIT_MASK>>>DIGIT_BITS-count}function copyArray(source,sourceIndex,destination,destIndex,length){while(length-- >0){destination[destIndex+length]=source[sourceIndex+length]}}function isZero(array){var i;for(i=0;i<array.length;i+=1){if(array[i]!==0){return false}}return true}function isEven(array){return(array[0]&1)===0}function sequenceEqual(left,right){if(left.length!==right.length){return false}for(var i=0;i<left.length;i+=1){if(left[i]!==right[i]){return false}}return true}function bytesToDigits(bytes){var arrayLength=Math.floor((bytes.length+DIGIT_NUM_BYTES-1)/DIGIT_NUM_BYTES);var array=new Array(arrayLength);array[0]=0;var digit=0,index=0,scIndex=0;for(var i=bytes.length-1;i>=0;i--){digit=digit+DIGIT_SCALER[scIndex++]*(bytes[i]&255);if(DIGIT_SCALER[scIndex]===DIGIT_BASE){scIndex=0;array[index++]=digit;digit=0}}if(digit!==0){array[index]=digit}return array}function digitsToBytes(digits,trim,minTrimLength){var i,j,byte1;var bytes=[0];if(typeof trim==="undefined"){trim=true}for(i=0;i<digits.length;i+=1){byte1=digits[i];for(j=0;j<DIGIT_NUM_BYTES;j+=1){bytes[i*DIGIT_NUM_BYTES+j]=byte1&255;byte1=Math.floor(byte1/256)}}bytes=swapEndianness(bytes);if(minTrimLength===undefined){minTrimLength=1}if(trim){while(bytes.length>minTrimLength&&bytes[0]===0){bytes.shift()}}return bytes}function intToDigits(value,numDigits){if(typeof numDigits==="undefined"){if(value<=1){numDigits=1}else{var numBits=Math.log(value)/Math.LN2;numDigits=Math.ceil(numBits/DIGIT_BITS)}}var digitRepresentation=[];while(value>0){digitRepresentation.push(value%DIGIT_BASE);value=Math.floor(value/DIGIT_BASE)}while(digitRepresentation.length<numDigits){digitRepresentation.push(0)}return digitRepresentation}function mswIndex(digits){for(var i=digits.length-1;i>=0;i--){if(digits[i]!==undefined&&digits[i]!==0){return i}}return digits[0]===0?-1:0}function compareDigits(left,right){var comparisonResult=0;var nLeft=mswIndex(left)+1;var nRight=mswIndex(right)+1;if(nLeft>nRight){comparisonResult=1}else if(nRight>nLeft){comparisonResult=-1}else{while(nLeft-- >0&&comparisonResult===0){comparisonResult=left[nLeft]-right[nLeft]}}return comparisonResult}function normalizeDigitArray(digits,length,pad){var i=mswIndex(digits);digits.length=length||i+1;if(pad){while(++i<digits.length){digits[i]=0}}if(digits.length<=0){digits[0]=0;digits.length=1}return digits}function shiftRight(source,destination,bits,length){if(bits===undefined){bits=1}else if(bits>=DIGIT_BITS||bits<0){throw new Error("Invalid bit count for shiftRight")}if(length===undefined){length=source.length}var n=length-1;var leftShiftBitCount=DIGIT_BITS-bits;for(var i=0;i<n;i++){destination[i]=(source[i+1]<<leftShiftBitCount|source[i]>>>bits)&DIGIT_MASK}destination[n]=source[n]>>>bits}function shiftLeft(source,destination,bits,length){if(bits===undefined){bits=1}else if(bits>=DIGIT_BITS||bits<0){throw new Error("bit count must be smaller than DIGIT_BITS and positive in shiftLeft")}if(length===undefined){length=source.length}var rightShiftBitCount=DIGIT_BITS-bits;destination[length]=source[length-1]>>>DIGIT_BITS-bits||destination[length];for(var i=length-1;i>0;i--){destination[i]=(source[i]<<bits|source[i-1]>>>rightShiftBitCount)&DIGIT_MASK}destination[0]=source[0]<<bits&DIGIT_MASK}function add(addend1,addend2,sum){var shortArray=addend1;var longArray=addend2;if(addend2.length<addend1.length){shortArray=addend2;longArray=addend1}var s=shortArray.length;var carry=0;var i;for(i=0;i<s;i+=1){carry+=shortArray[i]+longArray[i];sum[i]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}for(i=s;i<longArray.length;i+=1){carry+=longArray[i];sum[i]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}sum.length=longArray.length;if(carry!==0){sum[i]=carry&DIGIT_MASK}return carry}function subtract(minuend,subtrahend,difference){var s=subtrahend.length;if(minuend.length<subtrahend.length){s=mswIndex(subtrahend)+1;if(minuend.length<s){throw new Error("Subtrahend is longer than minuend, not supported.")}}var i,carry=0;for(i=0;i<s;i+=1){carry+=minuend[i]-subtrahend[i];difference[i]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}while(i<minuend.length){carry+=minuend[i];difference[i++]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}return carry}function multiply(multiplicant,multiplier,product){var mplr=typeof multiplier==="number"?[multiplier]:multiplier;var s=Math.max(multiplicant.length,mplr.length);var i,j,u;for(i=0;i<s;i+=1){product[i]=0}for(i=0;i<mplr.length;i+=1){u=0;for(j=0;j<multiplicant.length;j+=1){u+=multiplicant[j]*mplr[i]+product[i+j];product[i+j]=u&DIGIT_MASK;u=Math.floor(u/DIGIT_BASE)}product[multiplicant.length+i]=u&DIGIT_MASK}product.length=multiplicant.length+mplr.length;return product}function divRem(dividend,divisor,quotient,remainder,temp1,temp2){var m=mswIndex(dividend)+1;var n=mswIndex(divisor)+1;var qhat,rhat,carry,p,t,i,j;if(m<n){copyArray(dividend,0,remainder,0,dividend.length);remainder.length=dividend.length;normalizeDigitArray(remainder);quotient[0]=0;quotient.length=1;return}else if(n===0||n===1&&divisor[n-1]===0){throw new Error("Division by zero.")}else if(n===1){t=divisor[0];rhat=0;for(j=m-1;j>=0;j--){p=rhat*DIGIT_BASE+dividend[j];quotient[j]=p/t&DIGIT_MASK;rhat=p-quotient[j]*t&DIGIT_MASK}quotient.length=m;normalizeDigitArray(quotient);remainder[0]=rhat;remainder.length=1;return}var s=DIGIT_BITS-1-bitScanForward(divisor[n-1]);var vn=temp1||[];vn.length=n;shiftLeft(divisor,vn,s,n);var un=temp2||[];un.length=m;shiftLeft(dividend,un,s,m);un[m]=un[m]||0;quotient.length=m-n+1;remainder.length=n;for(j=m-n;j>=0;j--){qhat=Math.floor((un[j+n]*DIGIT_BASE+un[j+n-1])/vn[n-1]);rhat=un[j+n]*DIGIT_BASE+un[j+n-1]-qhat*vn[n-1];while(true){if(qhat>=DIGIT_BASE||qhat*vn[n-2]>rhat*DIGIT_BASE+un[j+n-2]){qhat=qhat-1;rhat=rhat+vn[n-1];if(rhat<DIGIT_BASE){continue}}break}carry=0;for(i=0;i<n;i++){p=qhat*vn[i];t=un[i+j]-carry-(p&DIGIT_MASK);un[i+j]=t&DIGIT_MASK;carry=Math.floor(p/DIGIT_BASE)-Math.floor(t/DIGIT_BASE)}t=un[j+n]-carry;un[j+n]=t&DIGIT_MASK;quotient[j]=qhat&DIGIT_MASK;if(t<0){quotient[j]=quotient[j]-1;carry=0;for(i=0;i<n;i++){t=un[i+j]+vn[i]+carry;un[i+j]=t&DIGIT_MASK;carry=t>>DIGIT_BITS}un[j+n]=un[j+n]+carry&DIGIT_MASK}}for(i=0;i<n;i++){remainder[i]=(un[i]>>>s|un[i+1]<<DIGIT_BITS-s)&DIGIT_MASK}normalizeDigitArray(quotient);normalizeDigitArray(remainder)}function reduce(number,modulus,remainder,temp1,temp2){var quotient=[];divRem(number,modulus,quotient,remainder,temp1,temp2);return remainder}function modMul(multiplicant,multiplier,modulus,product,temp1,temp2){var quotient=[];multiply(multiplicant,multiplier,quotient);divRem(quotient,modulus,quotient,product,temp1,temp2);return product}function eea(a,b,upp,vpp,rpp){var rp;if(isZero(a)){copyArray(b,0,rpp,0,b.length);rpp.length=b.length;return 0}else if(isZero(b)){copyArray(a,0,rpp,0,a.length);rpp.length=a.length;return 0}else if(compareDigits(a,b)<0){rp=a.slice(0);copyArray(b,0,rpp,0,b.length);rpp.length=b.length}else{rp=b.slice(0);copyArray(a,0,rpp,0,a.length);rpp.length=a.length}normalizeDigitArray(rpp);normalizeDigitArray(rp);var q=new Array(rpp.length);var r=new Array(rpp.length);var v=new Array(rpp.length);var vppPresent=vpp!==undefined;var vp;if(vppPresent){vp=new Array(rpp.length);vp[0]=1;vp.length=1;vpp[0]=0;vpp.length=1}var up;var u=new Array(rpp.length);var uppPresent=upp!==undefined;if(uppPresent){up=new Array(rpp.length);up[0]=0;up.length=1;upp[0]=1;upp.length=1}var k=-1;var upp_out=upp;var vpp_out=vpp;var rpp_out=rpp;var save;while(!isZero(rp)){divRem(rpp,rp,q,r,u,v);if(uppPresent){multiply(q,up,u);add(u,upp,u);normalizeDigitArray(u);save=upp;upp=up;up=u;u=save}if(vppPresent){multiply(q,vp,v);add(v,vpp,v);normalizeDigitArray(v);save=vpp;vpp=vp;vp=v;v=save}save=rpp;rpp=rp;rp=r;r=save;k++}if(uppPresent){copyArray(upp,0,upp_out,0,upp.length);upp_out.length=upp.length}if(vppPresent){copyArray(vpp,0,vpp_out,0,vpp.length);vpp_out.length=vpp.length}copyArray(rpp,0,rpp_out,0,rpp.length);rpp_out.length=rpp.length;return k}function gcd(a,b,output){var aa=a;var bb=b;if(compareDigits(a,b)>0){aa=b;bb=a}eea(aa,bb,undefined,undefined,output);return normalizeDigitArray(output)}function modInv(a,n,aInv){var upp=new Array(n.length);var vpp=new Array(n.length);var rpp=new Array(n.length);var k=eea(a,n,vpp,upp,rpp);aInv=aInv||[];if(compareDigits(rpp,One)!==0){aInv[0]=NaN;aInv.length=1}else{if((k&1)===1){subtract(n,upp,aInv)}else{copyArray(upp,0,aInv,0,upp.length);aInv.length=upp.length}normalizeDigitArray(aInv)}return aInv}function modExp(base,exponent,modulus,result){result=result||[];if(compareDigits(exponent,Zero)===0){result[0]=1}else if(compareDigits(exponent,One)===0){copyArray(base,0,result,0,base.length);result.length=base.length}else{var montmul=new MontgomeryMultiplier(modulus);normalizeDigitArray(base,montmul.s,true);montmul.modExp(base,exponent,result);result.length=modulus.length}return result}function MontgomeryMultiplier(modulus){function computeM0Prime(m0){var m0Pr=1;var a=2;var b=3;var c=b&m0;for(var i=2;i<=DIGIT_BITS;i+=1){if(a<c){m0Pr+=a}a=a<<1;b=b<<1|1;c=m0*m0Pr&b}var result=(~m0Pr&DIGIT_MASK)+1;return result}function montgomeryMultiply(multiplicant,multiplier,result,ctx){ctx=ctx||this;var resultHigh=0;var s=ctx.m.length;var sMinus1=s-1;var mPrime=ctx.mPrime;var m0=ctx.m0;var left0=multiplicant[0];var uv=0,rightI,q,i,j,k;for(i=0;i<s;i+=1){result[i]=0}for(i=0;i<s;i+=1){rightI=multiplier[i];uv=left0*rightI+result[0];result[0]=uv&DIGIT_MASK;uv=Math.floor(uv/DIGIT_BASE);for(j=1;j<s;j+=1){uv=multiplicant[j]*rightI+result[j]+uv;result[j]=uv&DIGIT_MASK;uv=Math.floor(uv/DIGIT_BASE)}resultHigh=resultHigh+uv;q=result[0]*mPrime&DIGIT_MASK;uv=Math.floor((result[0]+m0*q)/DIGIT_BASE);for(j=1,k=0;j<s;j+=1,k++){uv=ctx.m[j]*q+result[j]+uv;result[k]=uv&DIGIT_MASK;uv=Math.floor(uv/DIGIT_BASE)}resultHigh+=uv;result[sMinus1]=resultHigh&DIGIT_MASK;resultHigh=Math.floor(resultHigh/DIGIT_BASE)}var resultMinusM=ctx.temp1===result?ctx.temp2:ctx.temp1,carry=0;for(i=0;i<s;i+=1){carry=result[i]-ctx.m[i]+(carry>>DIGIT_BITS);resultMinusM[i]=carry&DIGIT_MASK}carry=(resultHigh&DIGIT_MASK)+(carry>>DIGIT_BITS);carry=(resultHigh>>>DIGIT_BITS)+(carry>>DIGIT_BITS);for(i=0;i<s;i+=1){result[i]=carry&(resultMinusM[i]^result[i])^resultMinusM[i]}return}function convertToMontgomeryForm(digits){if(digits.length<this.s){digits.length=this.s;for(var i=0;i<this.s;i++){digits[i]=isNaN(digits[i])?0:digits[i]}}var result=createArray(digits.length);this.montgomeryMultiply(digits,this.rSquaredModm,result);for(i=0;i<this.s;i+=1){digits[i]=result[i]}}function convertToStandardForm(digits){this.montgomeryMultiply(digits,this.one,this.temp1);for(var i=0;i<this.s;i+=1){digits[i]=this.temp1[i]}}function modExp(base,exponent,result){var i;var expBitsToScan=2;var expMask=DIGIT_MASK>>>DIGIT_BITS-expBitsToScan;for(i=exponent.length-1;i>0&&exponent[i]===0;i--){}var bitsToScan=i*DIGIT_BITS+bitScanForward(exponent[i])+1;bitsToScan=bitsToScan+(expBitsToScan-bitsToScan%expBitsToScan);var shiftAmt=bitsToScan%DIGIT_BITS-expBitsToScan;if(shiftAmt<0){shiftAmt+=DIGIT_BITS}var mask=expMask<<shiftAmt;for(i=1;i<baseTable.length;i++){modMul(baseTable[i-1],base,this.m,baseTable[i],temp1,temp2);normalizeDigitArray(baseTable[i],this.s,true)}var fourthPower=new Array(this.s);var squared=result;var partialResult=temp2;copyArray(this.rModM,0,partialResult,0,this.s);var tableIndex;while(bitsToScan>0){this.montgomeryMultiply(partialResult,partialResult,squared);this.montgomeryMultiply(squared,squared,fourthPower);tableIndex=(exponent[Math.floor((bitsToScan-1)/DIGIT_BITS)]&mask)>>>shiftAmt;this.montgomeryMultiply(fourthPower,baseTable[tableIndex],partialResult);bitsToScan=bitsToScan-expBitsToScan;shiftAmt=shiftAmt-expBitsToScan;mask=mask>>>expBitsToScan;if(mask===0){mask=expMask<<DIGIT_BITS-expBitsToScan;shiftAmt=DIGIT_BITS-expBitsToScan}}this.montgomeryMultiply(partialResult,this.one,result);return result}var m=modulus;var m0=m[0];var s=m.length;var one=createArray(s);one[0]=1;var mPrime=computeM0Prime(m0);var quotient=createArray(2*s+1);var rRemainder=createArray(s+1);var temp1=createArray(2*s+1);var temp2=createArray(2*s+1);var rDigits=rRemainder;rDigits[s]=1;divRem(rDigits,m,quotient,rRemainder,temp1,temp2);var rModM=normalizeDigitArray(rRemainder,s,true);var rSquaredModm=createArray(2*s+1);var rSquaredDigits=rSquaredModm;rSquaredDigits[s*2]=1;divRem(rSquaredDigits,m,quotient,rSquaredModm,temp1,temp2);normalizeDigitArray(rSquaredModm,s,true);var rCubedModm=createArray(s);var ctx={m:m,mPrime:mPrime,m0:m0,temp1:temp1,temp2:temp2};montgomeryMultiply(rSquaredModm,rSquaredModm,rCubedModm,ctx);var baseTable=new Array(4);baseTable[0]=rModM;baseTable[1]=new Array(s);baseTable[2]=new Array(s);baseTable[3]=new Array(s);return{m:modulus,m0:m0,mPrime:mPrime,rSquaredModm:rSquaredModm,s:s,rModM:rModM,rCubedModm:rCubedModm,one:one,temp1:temp1,temp2:temp2,convertToMontgomeryForm:convertToMontgomeryForm,convertToStandardForm:convertToStandardForm,montgomeryMultiply:montgomeryMultiply,modExp:modExp}}function IntegerGroup(modulusBytes){var m_modulus=bytesToDigits(modulusBytes);var m_digitWidth=m_modulus.length;var m_zero=intToDigits(0,m_digitWidth);var m_one=intToDigits(1,m_digitWidth);var temp0=createArray(m_digitWidth);var temp1=createArray(m_digitWidth);var montmul=new MontgomeryMultiplier(m_modulus);function createElementFromBytes(bytes){var digits=bytesToDigits(bytes);if(cryptoMath.compareDigits(digits,this.m_modulus)>=0){throw new Error("The number provided is not an element of this group")}normalizeDigitArray(digits,this.m_digitWidth,true);return integerGroupElement(digits,this)}function createElementFromInteger(integer){var digits=intToDigits(integer,this.m_digitWidth);return integerGroupElement(digits,this)}function createElementFromDigits(digits){cryptoMath.normalizeDigitArray(digits,this.m_digitWidth,true);return integerGroupElement(digits,this)}function equals(otherGroup){return compareDigits(this.m_modulus,otherGroup.m_modulus)===0}function add(addend1,addend2,sum){var i;var s=this.m_digitWidth;var result=sum.m_digits;cryptoMath.add(addend1.m_digits,addend2.m_digits,result);var mask=compareDigits(result,this.m_modulus)>=0?DIGIT_MASK:0;var carry=0;for(i=0;i<s;i+=1){carry=result[i]-(this.m_modulus[i]&mask)+carry;result[i]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}result.length=s}function subtract(leftElement,rightElement,outputElement){var i,s=this.m_digitWidth;var result=outputElement.m_digits;var carry=cryptoMath.subtract(leftElement.m_digits,rightElement.m_digits,outputElement.m_digits);if(carry===-1){carry=0;for(i=0;i<s;i+=1){carry+=result[i]+this.m_modulus[i];result[i]=carry&DIGIT_MASK;carry=carry>>DIGIT_BITS}}}function inverse(element,outputElement){cryptoMath.modInv(element.m_digits,this.m_modulus,outputElement.m_digits)}function multiply(multiplicant,multiplier,product){return cryptoMath.modMul(multiplicant.m_digits,multiplier.m_digits,this.m_modulus,product.m_digits,temp0,temp1)}function modexp(valueElement,exponent,outputElement){outputElement=outputElement||integerGroupElement([],this);if(compareDigits(exponent,m_zero)===0){outputElement.m_digits=intToDigits(1,this.m_digitWidth)}else if(compareDigits(exponent,m_one)===0){for(var i=0;i<valueElement.m_digits.length;i++){outputElement.m_digits[i]=valueElement.m_digits[i]}outputElement.m_digits.length=valueElement.m_digits.length}else{this.montmul.modExp(valueElement.m_digits,exponent,outputElement.m_digits);outputElement.m_digits.length=this.montmul.s}return outputElement}function integerGroupElement(digits,group){return{m_digits:digits,m_group:group,equals:function(element){return compareDigits(this.m_digits,element.m_digits)===0&&this.m_group.equals(this.m_group,element.m_group)}}}return{m_modulus:m_modulus,m_digitWidth:m_digitWidth,montmul:montmul,createElementFromInteger:createElementFromInteger,createElementFromBytes:createElementFromBytes,createElementFromDigits:createElementFromDigits,equals:equals,add:add,subtract:subtract,multiply:multiply,inverse:inverse,modexp:modexp}}return{DIGIT_BITS:DIGIT_BITS,DIGIT_NUM_BYTES:DIGIT_NUM_BYTES,DIGIT_MASK:DIGIT_MASK,DIGIT_BASE:DIGIT_BASE,DIGIT_MAX:DIGIT_MAX,Zero:Zero,One:One,normalizeDigitArray:normalizeDigitArray,swapEndianness:swapEndianness,bytesToDigits:bytesToDigits,stringToDigits:stringToDigits,digitsToString:digitsToString,intToDigits:intToDigits,digitsToBytes:digitsToBytes,sequenceEqual:sequenceEqual,isZero:isZero,isEven:isEven,powerOfTwo:powerOfTwo,shiftRight:shiftRight,shiftLeft:shiftLeft,compareDigits:compareDigits,computeBitArray:computeBitArray,bitLength:highestSetBit,fixedWindowRecode:fixedWindowRecode,IntegerGroup:IntegerGroup,add:add,subtract:subtract,multiply:multiply,divRem:divRem,reduce:reduce,modInv:modInv,modExp:modExp,modMul:modMul,MontgomeryMultiplier:MontgomeryMultiplier,gcd:gcd}}var cryptoMath=cryptoMath||msrcryptoMath();function MsrcryptoECC(){function createArray(parameter){var i,array=null;if(!arguments.length||typeof arguments[0]==="number"){array=[];for(i=0;i<parameter;i+=1){array[i]=0}}else if(typeof arguments[0]==="object"){array=[];for(i=0;i<parameter.length;i+=1){array[i]=parameter[i]}}return array}var btd=cryptoMath.bytesToDigits;var EllipticCurveFp=function(p1,a1,b1,order,gx,gy){var fieldStorageBitLength=p1.length;var generator=EllipticCurvePointFp(this,false,gx,gy,null,false);return{p:p1,a:a1,b:b1,order:order,generator:generator,allocatePointStorage:function(){return EllipticCurvePointFp(this,false,cryptoMath.intToDigits(0,fieldStorageBitLength),cryptoMath.intToDigits(0,fieldStorageBitLength))},createPointAtInfinity:function(){return EllipticCurvePointFp(this,true,cryptoMath.intToDigits(0,fieldStorageBitLength),cryptoMath.intToDigits(0,fieldStorageBitLength))}}};var createWeierstrassCurve=function(curveData){var newCurve=new EllipticCurveFp(btd(curveData.p),btd(curveData.a),btd(curveData.b),btd(curveData.order),btd(curveData.gx),btd(curveData.gy));newCurve.type=curveData.type;newCurve.name=curveData.name;newCurve.generator.curve=newCurve;return newCurve};var createTedCurve=function(curveData){var btd=cryptoMath.bytesToDigits;var newCurve=new EllipticCurveFp(btd(curveData.p),btd(curveData.a),btd(curveData.d),btd(curveData.order),btd(curveData.gx),btd(curveData.gy));newCurve.type=curveData.type;if(newCurve.type==1){newCurve.d=newCurve.b.slice();delete newCurve.b}newCurve.rbits=curveData.info[2];newCurve.name=curveData.name;newCurve.generator.curve=newCurve;return newCurve};var EllipticCurvePointFp=function(curve,isInfinity,x,y,z,isInMontgomeryForm){var returnObj;if(typeof z==="undefined"){z=null}if(typeof isInMontgomeryForm==="undefined"){
isInMontgomeryForm=false}function equals(ellipticCurvePointFp){if(!ellipticCurvePointFp){return false}if(returnObj.isInfinity&&ellipticCurvePointFp.isInfinity){return true}if(returnObj.z===null&&ellipticCurvePointFp.z!==null){return false}if(returnObj.z!==null&&ellipticCurvePointFp.z===null){return false}if(returnObj.z===null){return cryptoMath.compareDigits(returnObj.x,ellipticCurvePointFp.x)===0&&cryptoMath.compareDigits(returnObj.y,ellipticCurvePointFp.y)===0&&returnObj.isInMontgomeryForm===ellipticCurvePointFp.isInMontgomeryForm}return cryptoMath.compareDigits(returnObj.x,ellipticCurvePointFp.x)===0&&cryptoMath.compareDigits(returnObj.y,ellipticCurvePointFp.y)===0&&cryptoMath.compareDigits(returnObj.z,ellipticCurvePointFp.z)===0&&returnObj.isInMontgomeryForm===ellipticCurvePointFp.isInMontgomeryForm}function copyTo(source,destination){destination.curve=source.curve;destination.x=source.x.slice();destination.y=source.y.slice();if(source.z!==null){destination.z=source.z.slice()}else{destination.z=null}setterSupport||(destination.isAffine=source.isAffine);destination.isInMontgomeryForm=source.isInMontgomeryForm;destination.isInfinity=source.isInfinity;if(!destination.equals(source)){throw new Error("Instances should be equal.")}}function clone(){var clonePoint=EllipticCurvePointFp(returnObj.curve,returnObj.isInfinity,createArray(returnObj.x),createArray(returnObj.y),returnObj.z?createArray(returnObj.z):null,returnObj.isInMontgomeryForm);returnObj.ta&&(clonePoint.ta=createArray(returnObj.ta));returnObj.tb&&(clonePoint.tb=createArray(returnObj.tb));return clonePoint}returnObj={equals:function(ellipticCurvePointFp){return equals(ellipticCurvePointFp)},copy:function(destination){copyTo(this,destination);return},clone:function(){return clone()}};createProperty(returnObj,"curve",curve,function(){return curve},function(val){curve=val});createProperty(returnObj,"x",x,function(){return x},function(val){x=val});createProperty(returnObj,"y",y,function(){return y},function(val){y=val});createProperty(returnObj,"z",z,function(){return z},function(val){z=val});createProperty(returnObj,"isInMontgomeryForm",isInMontgomeryForm,function(){return isInMontgomeryForm},function(val){isInMontgomeryForm=val});createProperty(returnObj,"isInfinity",isInfinity,function(){return isInfinity},function(val){isInfinity=val});createProperty(returnObj,"isAffine",z===null,function(){return z===null});return returnObj};var EllipticCurveOperatorFp=function(curve){var m_curve=curve;var tedCurve=curve.type===1;var fieldElementWidth=curve.p.length;var montgomeryMultiplier=cryptoMath.MontgomeryMultiplier(curve.p);var montgomerizedA=curve.a.slice();montgomeryMultiplier.convertToMontgomeryForm(montgomerizedA);var aequalsZero=cryptoMath.isZero(curve.a);var one=cryptoMath.One;var onemontgomery=createArray(fieldElementWidth);onemontgomery[0]=1;montgomeryMultiplier.convertToMontgomeryForm(onemontgomery);var group=cryptoMath.IntegerGroup(cryptoMath.digitsToBytes(montgomeryMultiplier.m),true);var temp0=createArray(fieldElementWidth);var temp1=createArray(fieldElementWidth);var temp2=createArray(fieldElementWidth);var temp3=createArray(fieldElementWidth);var temp4=createArray(fieldElementWidth);var temp5=createArray(fieldElementWidth);var temp6=createArray(fieldElementWidth);var temp7=createArray(fieldElementWidth);var swap0=createArray(fieldElementWidth);var conversionTemp0=createArray(fieldElementWidth);var conversionTemp1=createArray(fieldElementWidth);var conversionTemp2=createArray(fieldElementWidth);function modSub(left,right,result){var resultElement=group.createElementFromInteger(0);resultElement.m_digits=result;group.subtract(group.createElementFromDigits(left),group.createElementFromDigits(right),resultElement)}function modAdd(left,right,result){var resultElement=group.createElementFromInteger(0);resultElement.m_digits=result;group.add(group.createElementFromDigits(left),group.createElementFromDigits(right),resultElement)}function modInv(number,result){cryptoMath.modInv(number,m_curve.p,result)}function modDivByTwo(dividend,result){var s=dividend.length;var modulus=curve.p;if((dividend[0]&1)===1){var carry=0;for(var i=0;i<s;i+=1){carry+=dividend[i]+modulus[i];result[i]=carry&cryptoMath.DIGIT_MASK;carry=carry>>>cryptoMath.DIGIT_BITS}carry=carry<<cryptoMath.DIGIT_BITS-1;cryptoMath.shiftRight(result,result);result[s-1]|=carry}else{cryptoMath.shiftRight(dividend,result)}}function montgomeryMultiply(left,right,result){montgomeryMultiplier.montgomeryMultiply(left,right,result)}function montgomerySquare(left,result){montgomeryMultiplier.montgomeryMultiply(left,left,result)}function correctInversion(digits){var results=createArray(digits.length);montgomeryMultiply(digits,montgomeryMultiplier.rCubedModm,results);for(var i=0;i<results.length;i+=1){digits[i]=results[i]}}function doubleAequalsNeg3(point,outputPoint){if(point.isInfinity){outputPoint.isInfinity=true;return}montgomerySquare(point.z,temp1);montgomeryMultiply(point.z,point.y,temp4);modAdd(point.x,temp1,temp2);modSub(point.x,temp1,temp1);outputPoint.z=temp4.slice();montgomeryMultiply(temp1,temp2,temp3);modDivByTwo(temp3,temp2);modAdd(temp3,temp2,temp1);montgomerySquare(point.y,temp2);montgomerySquare(temp1,temp4);montgomeryMultiply(point.x,temp2,temp3);modSub(temp4,temp3,temp4);modSub(temp4,temp3,outputPoint.x);modSub(temp3,outputPoint.x,temp4);montgomerySquare(temp2,temp3);montgomeryMultiply(temp1,temp4,temp2);modSub(temp2,temp3,outputPoint.y);outputPoint.isInfinity=false;outputPoint.isInMontgomeryForm=true}function doubleAequals0(point,outputPoint){if(point.isInfinity){outputPoint.isInfinity=true;return}montgomerySquare(point.y,temp3);montgomerySquare(point.x,temp4);modAdd(temp4,temp4,temp0);modAdd(temp0,temp4,temp4);montgomeryMultiply(point.x,temp3,temp5);montgomerySquare(temp3,temp0);modDivByTwo(temp4,temp1);montgomerySquare(temp1,temp3);montgomeryMultiply(point.y,point.z,swap0);for(var i=0;i<swap0.length;i+=1){outputPoint.z[i]=swap0[i]}modSub(temp3,temp5,outputPoint.x);modSub(outputPoint.x,temp5,outputPoint.x);modSub(temp5,outputPoint.x,temp4);montgomeryMultiply(temp1,temp4,temp2);modSub(temp2,temp0,outputPoint.y);outputPoint.isInfinity=false;outputPoint.isInMontgomeryForm=true}function generatePrecomputationTable(w,generatorPoint){var validationPoint=generatorPoint.clone();convertToStandardForm(validationPoint);if(!validatePoint(validationPoint)){throw new Error("Invalid Parameter")}var pointJac=generatorPoint.clone();convertToJacobianForm(pointJac);var tablePos=[generatorPoint.clone()];var qJac=pointJac.clone();var px2=pointJac.clone();double(pointJac,px2);convertToAffineForm(px2);var qAff;for(var i=1;i<Math.pow(2,w-2);i++){mixedAdd(qJac,px2,qJac);qAff=qJac.clone();convertToAffineForm(qAff);tablePos[i]=qAff}return tablePos}function double(point,outputPoint){if(typeof point==="undefined"){throw new Error("point undefined")}if(typeof outputPoint==="undefined"){throw new Error("outputPoint undefined")}if(point.isAffine){throw new Error("Given point was in Affine form. Use convertToJacobian() first.")}if(!point.isInMontgomeryForm){throw new Error("Given point must be in Montgomery form. Use montgomeryize() first.")}if(aequalsZero){doubleAequals0(point,outputPoint)}else{doubleAequalsNeg3(point,outputPoint)}}function mixedDoubleAdd(jacobianPoint,affinePoint,outputPoint){if(jacobianPoint.isInfinity){affinePoint.copy(outputPoint);this.convertToJacobianForm(outputPoint);return}if(affinePoint.isInfinity){jacobianPoint.copy(outputPoint);return}montgomerySquare(jacobianPoint.z,temp5);montgomeryMultiply(jacobianPoint.z,temp5,temp6);montgomeryMultiply(affinePoint.x,temp5,temp4);montgomeryMultiply(affinePoint.y,temp6,temp5);modSub(temp4,jacobianPoint.x,temp1);modSub(temp5,jacobianPoint.y,temp2);montgomerySquare(temp2,temp4);montgomerySquare(temp1,temp6);montgomeryMultiply(temp6,jacobianPoint.x,temp5);montgomeryMultiply(temp1,temp6,temp0);modSub(temp4,temp5,temp3);modSub(temp3,temp5,temp3);montgomeryMultiply(jacobianPoint.z,temp1,temp4);modSub(temp3,temp5,temp3);montgomeryMultiply(temp0,jacobianPoint.y,temp6);modSub(temp3,temp0,temp3);var temp3isZero=true;for(var i=0;i<temp3.length;i++){if(temp3[1]!==0){temp3isZero=false;break}}if(temp3isZero){for(i=0;i<outputPoint.x.length;i++){outputPoint.x[i]=0;outputPoint.y[i]=0;outputPoint.z[i]=0}outputPoint.y[0]=1;return}modAdd(temp6,temp6,temp1);montgomeryMultiply(temp4,temp3,outputPoint.z);montgomeryMultiply(temp2,temp3,temp4);montgomerySquare(temp3,temp0);modAdd(temp1,temp4,temp1);montgomeryMultiply(temp0,temp5,temp4);montgomerySquare(temp1,temp7);montgomeryMultiply(temp0,temp3,temp5);modSub(temp7,temp4,outputPoint.x);modSub(outputPoint.x,temp4,outputPoint.x);modSub(outputPoint.x,temp5,outputPoint.x);modSub(outputPoint.x,temp4,temp3);montgomeryMultiply(temp5,temp6,temp0);montgomeryMultiply(temp1,temp3,temp4);modSub(temp4,temp0,outputPoint.y);outputPoint.isInfinity=false;outputPoint.isInMontgomeryForm=true}function mixedAdd(jacobianPoint,affinePoint,outputPoint){if(jacobianPoint===null){throw new Error("jacobianPoint")}if(affinePoint===null){throw new Error("affinePoint")}if(outputPoint===null){throw new Error("outputPoint")}if(jacobianPoint.curve!==affinePoint.curve||jacobianPoint.curve!==outputPoint.curve){throw new Error("All points must be from the same curve object.")}if(jacobianPoint.isAffine){throw new Error("Given jacobianPoint was in Affine form. Use ConvertToJacobian() before calling DoubleJacobianAddAffinePoints().")}if(!affinePoint.isAffine){throw new Error("Given affinePoint was in Jacobian form. Use ConvertToAffine() before calling DoubleJacobianAddAffinePoints().")}if(outputPoint.isAffine){throw new Error("Given jacobianPoint was in Jacobian form. Use ConvertToJacobian() before calling DoubleJacobianAddAffinePoints().")}if(!jacobianPoint.isInMontgomeryForm){throw new Error("Jacobian point must be in Montgomery form")}if(!affinePoint.isInMontgomeryForm){throw new Error("Affine point must be in Montgomery form")}if(jacobianPoint.isInfinity){affinePoint.copy(outputPoint);this.convertToJacobianForm(outputPoint);return}if(affinePoint.isInfinity){jacobianPoint.copy(outputPoint);return}montgomerySquare(jacobianPoint.z,temp1);montgomeryMultiply(temp1,jacobianPoint.z,temp2);montgomeryMultiply(temp1,affinePoint.x,temp3);montgomeryMultiply(temp2,affinePoint.y,temp4);modSub(temp3,jacobianPoint.x,temp1);modSub(temp4,jacobianPoint.y,temp2);var i;for(i=0;i<temp1.length;i+=1){if(temp1[i]!==0){montgomeryMultiply(jacobianPoint.z,temp1,temp0);for(var j=0;j<fieldElementWidth;j+=1){outputPoint.z[j]=temp0[j]}montgomerySquare(temp1,temp3);montgomeryMultiply(temp3,temp1,temp4);montgomeryMultiply(temp3,jacobianPoint.x,temp5);modAdd(temp5,temp5,temp1);montgomerySquare(temp2,outputPoint.x);modSub(outputPoint.x,temp1,outputPoint.x);modSub(outputPoint.x,temp4,outputPoint.x);modSub(temp5,outputPoint.x,temp3);montgomeryMultiply(temp2,temp3,temp5);montgomeryMultiply(jacobianPoint.y,temp4,temp6);modSub(temp5,temp6,outputPoint.y);outputPoint.isInfinity=false;outputPoint.isInMontgomeryForm=true;return}}for(i=0;i<temp2.length;i+=1){if(temp2[i]!==0){outputPoint.isInfinity=true;outputPoint.isInMontgomeryForm=true;return}}affinePoint.copy(outputPoint);this.convertToJacobianForm(outputPoint);this.double(outputPoint,outputPoint);outputPoint.isInMontgomeryForm=true}function scalarMultiply(k,point,outputPoint,muliplyBy4){if(point.isInfinity||cryptoMath.isZero(k)){outputPoint.isInfinity=true;return}if(cryptoMath.compareDigits(k,curve.order)>=0){throw new Error("The scalar k must be in the range 1 <= k < order.")}k=k.slice();if(point.curve.type===1){var pointIsEP=typeof point.ta!=="undefined";if(!pointIsEP){convertToExtendedProjective(point)}scalarMultiplyTed(k,point,outputPoint,muliplyBy4);if(!pointIsEP){normalizeTed(point)}}else{var pointIsMF=point.isInMontgomeryForm,outputIsMF=outputPoint.isInMontgomeryForm,outputIsAffine=outputPoint.isAffine;if(!pointIsMF){convertToMontgomeryForm(point)}if(!outputIsMF){convertToMontgomeryForm(outputPoint)}scalarMultiplyW(k,point,outputPoint);if(outputIsAffine){convertToAffineForm(outputPoint)}if(!pointIsMF){convertToStandardForm(point)}if(!outputIsMF){convertToStandardForm(outputPoint)}}return}function scalarMultiplyW(k,point,outputPoint){var validationPoint=point.clone();convertToStandardForm(validationPoint);if(!validatePoint(validationPoint)){throw new Error("Invalid Parameters.")}var odd=k[0]&1,tempk=[];modSub(point.curve.order,k,tempk);for(i=0;i<k.length;i++){k[i]=odd-1&(k[i]^tempk[i])^k[i]}var w=fieldElementWidth<=8?5:6;var m=point.curve.p.length*cryptoMath.DIGIT_BITS;var t=Math.ceil(m/(w-1));var kDigits=cryptoMath.fixedWindowRecode(k,w,t);var Tm=generatePrecomputationTable(w,point);var position=Math.floor(Math.abs(kDigits[t])-1)/2;var Q=Tm[position].clone();convertToJacobianForm(Q);for(var i=t-1;i>=0;i--){for(var j=0;j<w-2;j++){double(Q,Q)}position=Math.floor((Math.abs(kDigits[i])-1)/2);var L=tableLookupW(Tm,position);if(kDigits[i]<0){negate(L,L)}mixedDoubleAdd(Q,L,Q)}modSub(point.curve.p,Q.y,tempk);for(i=0;i<Q.y.length;i++){Q.y[i]=odd-1&(Q.y[i]^tempk[i])^Q.y[i]}Q.copy(outputPoint);return}function tableLookupW(table,index){var pos=(index+1)%table.length;for(var i=0;i<table.length;i++){var L=table[pos].clone();pos=(pos+1)%table.length}return L}function negate(point,outputPoint){if(point!==outputPoint){point.copy(outputPoint)}modSub(point.curve.p,point.y,outputPoint.y)}function convertToMontgomeryForm(point){if(point.isInMontgomeryForm){throw new Error("The given point is already in Montgomery form.")}if(!point.isInfinity){montgomeryMultiplier.convertToMontgomeryForm(point.x);montgomeryMultiplier.convertToMontgomeryForm(point.y);if(point.z!==null){montgomeryMultiplier.convertToMontgomeryForm(point.z)}if(typeof point.ta!=="undefined"){montgomeryMultiplier.convertToMontgomeryForm(point.ta);montgomeryMultiplier.convertToMontgomeryForm(point.tb)}}point.isInMontgomeryForm=true}function convertToStandardForm(point){if(!point.isInMontgomeryForm){throw new Error("The given point is not in montgomery form.")}if(!point.isInfinity){montgomeryMultiplier.convertToStandardForm(point.x);montgomeryMultiplier.convertToStandardForm(point.y);if(point.z!==null){montgomeryMultiplier.convertToStandardForm(point.z)}if(typeof point.ta!=="undefined"){montgomeryMultiplier.convertToStandardForm(point.ta);montgomeryMultiplier.convertToStandardForm(point.tb)}}point.isInMontgomeryForm=false}function convertToAffineForm(point){if(point.isInfinity){point.z=null;setterSupport||(point.isAffine=true);return}cryptoMath.modInv(point.z,curve.p,conversionTemp2);if(point.isInMontgomeryForm){montgomeryMultiply(conversionTemp2,montgomeryMultiplier.rCubedModm,conversionTemp1);var swap=conversionTemp2;conversionTemp2=conversionTemp1;conversionTemp1=swap}montgomerySquare(conversionTemp2,conversionTemp0);montgomeryMultiply(point.x,conversionTemp0,conversionTemp1);for(var i=0;i<fieldElementWidth;i+=1){point.x[i]=conversionTemp1[i]}montgomeryMultiply(point.y,conversionTemp0,conversionTemp1);montgomeryMultiply(conversionTemp1,conversionTemp2,point.y);point.z=null;delete point.ta;delete point.tb;setterSupport||(point.isAffine=true)}function convertToJacobianForm(point){if(!point.isAffine){throw new Error("The given point is not in Affine form.")}setterSupport||(point.isAffine=false);var clonedDigits,i,zOne=point.isInMontgomeryForm?onemontgomery:one;clonedDigits=createArray(zOne.length);for(i=0;i<zOne.length;i+=1){clonedDigits[i]=zOne[i]}point.z=clonedDigits;return}function validatePoint(point){if(point.isInfinity){return false}cryptoMath.modMul(point.y,point.y,point.curve.p,temp1);cryptoMath.modMul(point.x,point.x,point.curve.p,temp2);cryptoMath.modMul(point.x,temp2,point.curve.p,temp3);modAdd(temp3,point.curve.b,temp2);cryptoMath.modMul(point.x,point.curve.a,point.curve.p,temp3);modAdd(temp2,temp3,temp2);modSub(temp1,temp2,temp1);if(cryptoMath.isZero(temp1)==false){return false}return true}function validatePointTed(point){if(point.ta){point=point.clone();normalizeTed(point)}cryptoMath.modMul(point.y,point.y,point.curve.p,temp3);cryptoMath.modMul(point.x,point.x,point.curve.p,temp2);cryptoMath.add(temp2,temp3,temp1);cryptoMath.reduce(temp4,point.curve.p,temp4);cryptoMath.modMul(temp2,temp3,point.curve.p,temp4);cryptoMath.modMul(point.curve.d,temp4,point.curve.p,temp3);cryptoMath.add(temp3,[1],temp2);cryptoMath.reduce(temp2,point.curve.p,temp2);cryptoMath.subtract(temp1,temp2,temp1);cryptoMath.reduce(temp1,point.curve.p,temp1);if(cryptoMath.isZero(temp1)==false){return false}return true}function generatePrecomputationTableTed(npoints,point){var Q=point.clone(),P2=Q.clone(),T=[];T[0]=convert_R1_to_R2(point);doubleTed(Q,Q);P2=convert_R1_to_R2(Q);Q=point.clone();for(var i=1;i<npoints;i++){addTedExtended(P2,Q,Q);T[i]=convert_R1_to_R2(Q)}return T}function convertToExtendedProjective(affinePoint){affinePoint.ta=affinePoint.x.slice();affinePoint.tb=affinePoint.y.slice();affinePoint.z=[1]}function scalarMultiplyTed(k,point,outputPoint,multiplyBy4){if(!validatePointTed(point)){throw new Error("Invalid Parameter")}var rbits=point.curve.rbits;multiplyBy4=typeof multiplyBy4==="undefined"?true:multiplyBy4;var w=fieldElementWidth<=8?5:6;var t=Math.floor((rbits+(w-2))/(w-1));var i,j;k=k.slice();var T=point.clone();convertToExtendedProjective(T);if(multiplyBy4){doubleTed(T,T);doubleTed(T,T)}var precomputationTable=generatePrecomputationTableTed(1<<w-2,T);var odd=k[0]&1,tempk=[];modSub(point.curve.order,k,tempk);for(i=0;i<k.length;i++){k[i]=odd-1&(k[i]^tempk[i])^k[i]}var kDigits=cryptoMath.fixedWindowRecode(k,w,t);var position=Math.floor(Math.abs(kDigits[t])-1)/2;var R=precomputationTable[position];T.x=R.x.slice();T.y=R.y.slice();T.z=R.z.slice();for(i=t-1;i>=0;i--){for(j=0;j<w-1;j++){doubleTed(T,T)}position=Math.floor((Math.abs(kDigits[i])-1)/2);var L=tableLookupTed(precomputationTable,position);if(kDigits[i]<0){modSub(point.curve.p,L.x,L.x);modSub(point.curve.p,L.td,L.td)}addTedExtended(L,T,T)}modSub(point.curve.p,T.x,tempk);for(i=0;i<T.x.length;i++){T.x[i]=odd-1&(T.x[i]^tempk[i])^T.x[i]}normalizeTed(T);outputPoint.x=T.x.slice();outputPoint.y=T.y.slice();return}function tableLookupTed(table,index){var pos=(index+1)%table.length;for(var i=0;i<table.length;i++){var L={x:table[pos].x.slice(),y:table[pos].y.slice(),z:table[pos].z.slice(),td:table[pos].td.slice()};pos=(pos+1)%table.length}return L}function normalizeTed(point){cryptoMath.modInv(point.z,curve.p,conversionTemp2);cryptoMath.modMul(point.x,conversionTemp2,curve.p,point.x);cryptoMath.modMul(point.y,conversionTemp2,curve.p,point.y);delete point.ta;delete point.tb;point.z=null;return}function doubleTed(point,outputPoint){if(typeof point.ta==="undefined"){throw new Error("Point should be in Extended Projective form.")}cryptoMath.modMul(point.x,point.x,point.curve.p,temp0);cryptoMath.modMul(point.y,point.y,point.curve.p,temp1);cryptoMath.modMul(point.z,point.z,point.curve.p,point.ta);modSub(temp1,temp0,outputPoint.tb);modAdd(temp0,temp1,temp0);modAdd(point.ta,point.ta,point.ta);modAdd(point.y,point.y,point.y);modSub(point.ta,temp0,temp1);cryptoMath.modMul(point.x,point.y,point.curve.p,outputPoint.ta);cryptoMath.modMul(temp0,outputPoint.tb,point.curve.p,outputPoint.y);cryptoMath.modMul(temp1,outputPoint.ta,point.curve.p,outputPoint.x);cryptoMath.modMul(temp0,temp1,point.curve.p,outputPoint.z);return}function addTed(point1,point2,outputPoint){var cm=cryptoMath;var modulus=point1.curve.p;var temp1=[];if(typeof point1.ta==="undefined"){throw new Error("Point1 should be in Extended Projective form.")}if(typeof point2.ta==="undefined"){throw new Error("Point2 should be in Extended Projective form.")}var qq=convert_R1_to_R2(point1);addTedExtended(qq,point2,outputPoint);return}function convert_R1_to_R2(point){var curve=point.curve,modulus=curve.p,qq={x:point.x.slice(),y:point.y.slice(),z:point.z.slice(),td:[],curve:point.curve};cryptoMath.modMul(point.ta,point.tb,modulus,conversionTemp0);cryptoMath.modMul(conversionTemp0,curve.d,modulus,qq.td);return qq}function addTedExtended(qq,point2,outputPoint){var cm=cryptoMath;var modulus=point2.curve.p;temp1=[];temp2=[];temp3=[];cm.modMul(point2.z,qq.z,modulus,temp3);cm.modMul(point2.ta,point2.tb,modulus,temp1);modAdd(point2.x,point2.y,point2.ta);cm.modMul(temp1,qq.td,modulus,temp2);modAdd(qq.x,qq.y,point2.tb);modSub(temp3,temp2,temp1);modAdd(temp3,temp2,temp3);cm.modMul(point2.ta,point2.tb,modulus,temp2);cm.modMul(point2.x,qq.x,modulus,point2.z);cm.modMul(point2.y,qq.y,modulus,point2.x);modSub(temp2,point2.z,temp2);modSub(point2.x,point2.z,outputPoint.ta);modSub(temp2,point2.x,outputPoint.tb);cm.modMul(outputPoint.ta,temp3,modulus,outputPoint.y);cm.modMul(outputPoint.tb,temp1,modulus,outputPoint.x);cm.modMul(temp3,temp1,modulus,outputPoint.z);return}function convertTedToWeierstrass(tedPoint,wPoint){var a=tedPoint.curve.a.slice(),d=tedPoint.curve.d.slice(),p=tedPoint.curve.p,modMul=cryptoMath.modMul,modInv=cryptoMath.modInv;temp1=[5];modMul(a,temp1,p,temp2);modSub(temp2,d,temp2);modMul(d,temp1,p,temp3);modSub(a,temp3,temp1);modMul(tedPoint.y,temp1,p,temp3);modAdd(temp3,temp2,temp2);temp1=[1];modSub(temp1,tedPoint.y,temp3);temp1=[12];modMul(temp1,temp3,p,temp4);modInv(temp4,p,temp4);modMul(tedPoint.x,temp3,p,temp1);modAdd(temp1,temp1,temp3);modAdd(temp3,temp3,temp3);modInv(temp3,p,temp3);modMul(temp4,temp2,p,wPoint.x);temp1=[1];modAdd(tedPoint.y,temp1,temp1);modSub(a,d,temp2);modMul(temp1,temp2,p,temp4);modMul(temp4,temp3,p,wPoint.y);return}function convertWeierstrassToTed(wPoint,tedPoint){var a=tedPoint.curve.a.slice(),d=tedPoint.curve.d.slice(),p=tedPoint.curve.p,modMul=cryptoMath.modMul,modInv=cryptoMath.modInv;modAdd(wPoint.x,wPoint.x,temp1);modAdd(wPoint.x,temp1,temp1);modAdd(temp1,temp1,temp1);modSub(temp1,a,temp2);modSub(temp2,d,temp2);modAdd(wPoint.y,wPoint.y,temp3);modAdd(wPoint.y,temp3,temp3);modAdd(temp3,temp3,temp3);modInv(temp3,p,temp3);modMul(temp2,temp3,p,tedPoint.x);modAdd(temp1,temp1,temp1);modAdd(temp1,d,temp2);modAdd(temp1,a,temp1);modAdd(a,a,temp3);modSub(temp2,temp3,temp2);modSub(temp2,temp3,temp2);modSub(temp2,a,temp2);modAdd(d,d,temp3);modSub(temp1,temp3,temp1);modSub(temp1,temp3,temp1);modSub(temp1,d,temp1);modInv(temp1,p,temp1);modMul(temp1,temp2,p,tedPoint.y);return}var methods={convertToMontgomeryForm:convertToMontgomeryForm,convertToStandardForm:convertToStandardForm,convertToAffineForm:convertToAffineForm,convertToJacobianForm:convertToJacobianForm,generatePrecomputationTable:function(w,generatorPoint){return generatePrecomputationTable(w,generatorPoint)}};if(tedCurve){methods.double=doubleTed;methods.add=addTed;methods.scalarMultiply=scalarMultiply;methods.normalize=normalizeTed;methods.convertToExtendedProjective=convertToExtendedProjective;methods.convertTedToWeierstrass=convertTedToWeierstrass;methods.convertWeierstrassToTed=convertWeierstrassToTed;methods.generatePrecomputationTable=function(w,generatorPoint){return generatePrecomputationTableTed(w,generatorPoint)}}else{methods.double=double;methods.mixedDoubleAdd=mixedDoubleAdd;methods.mixedAdd=mixedAdd;methods.scalarMultiply=scalarMultiply;methods.negate=negate}return methods};var sec1EncodingFp=function(){return{encodePoint:function(point){if(!point){throw new Error("point")}if(!point.isAffine){throw new Error("Point must be in affine form.")}if(point.isInMontgomeryForm){throw new Error("Point must not be in Montgomery form.")}if(point.isInfinity){return createArray(1)}else{var xOctetString=cryptoMath.digitsToBytes(point.x);var yOctetString=cryptoMath.digitsToBytes(point.y);var pOctetString=cryptoMath.digitsToBytes(point.curve.p);var mlen=pOctetString.length;if(mlen<xOctetString.length||mlen<yOctetString.length){throw new Error("Point coordinate(s) are bigger than the field order.")}var output=createArray(2*mlen+1);output[0]=4;var offset=mlen-xOctetString.length;for(var i=0;i<xOctetString.length;i++){output[i+1+offset]=xOctetString[i]}offset=mlen-yOctetString.length;for(i=0;i<yOctetString.length;i++){output[mlen+i+1+offset]=yOctetString[i]}return output}},decodePoint:function(encoded,curve){if(encoded.length<1){throw new Error("Byte array must have non-zero length")}var pOctetString=cryptoMath.digitsToBytes(curve.p);var mlen=pOctetString.length;if(encoded[0]===0&&encoded.length===1){return curve.createPointAtInfinity()}else if(encoded[0]===4&&encoded.length===1+2*mlen){var xbytes=createArray(mlen);var ybytes=createArray(mlen);for(var i=0;i<mlen;i++){xbytes[i]=encoded[i+1];ybytes[i]=encoded[mlen+i+1]}var x=cryptoMath.bytesToDigits(xbytes);var y=cryptoMath.bytesToDigits(ybytes);return EllipticCurvePointFp(curve,false,x,y)}else{throw new Error("Unsupported encoding format")}}}};var ModularSquareRootSolver=function(modulus){var p=modulus;var specialK=[];if(typeof modulus==="undefined"){throw new Error("modulus")}if(cryptoMath.isEven(modulus)){throw new Error("Only odd moduli are supported")}var mul=cryptoMath.MontgomeryMultiplier(p);if(p[0]%4===3){cryptoMath.add(p,cryptoMath.One,specialK);cryptoMath.shiftRight(specialK,specialK,2)}else{specialK=null}var temp0=new Array(p.length);var temp1=new Array(p.length);function squareRootNistCurves(a){var beta=cryptoMath.intToDigits(0,16);mul.modExp(a,specialK,beta);var aPrime=[0];cryptoMath.modMul(beta,beta,mul.m,aPrime);if(cryptoMath.compareDigits(a,aPrime)!==0){return null}return beta}var publicMethods={squareRoot:function(a){if(specialK!==null){return squareRootNistCurves(a)}else{throw new Error("GeneralCase not supported.")}},jacobiSymbol:function(a){var modEightMask=7,modFourMask=3,aPrime,pPrime;aPrime=a.slice();pPrime=p.slice();cryptoMath.reduce(aPrime,pPrime,aPrime,temp0,temp1);var t=1;while(!cryptoMath.isZero(aPrime)){while(cryptoMath.isEven(aPrime)){cryptoMath.shiftRight(aPrime,aPrime);var pMod8=pPrime[0]&modEightMask;if(pMod8===3||pMod8===5){t=-t}}var tmp=aPrime;aPrime=pPrime;pPrime=tmp;var aMod4=aPrime[0]&modFourMask;var pMod4=pPrime[0]&modFourMask;if(aMod4===3&&pMod4===3){t=-t}cryptoMath.reduce(aPrime,pPrime,aPrime,temp0,temp1)}if(cryptoMath.compareDigits(pPrime,cryptoMath.One)===0){return t}else{return 0}}};return publicMethods};var curvesInternal={};var createCurve=function(curveName){var curveData=curvesInternal[curveName.toUpperCase()];if(!curveData){throw new Error(curveName+" Unsupported curve.")}if(curveData.type===0){return createWeierstrassCurve(curveData)}if(curveData.type===1){return createTedCurve(curveData)}throw new Error(curveName+" Unsupported curve type.")};return{createCurve:createCurve,curves:curvesInternal,sec1EncodingFp:sec1EncodingFp,EllipticCurvePointFp:EllipticCurvePointFp,EllipticCurveOperatorFp:EllipticCurveOperatorFp,ModularSquareRootSolver:ModularSquareRootSolver}}var cryptoECC=cryptoECC||MsrcryptoECC();var curve_P256={name:"P-256",type:0,p:[255,255,255,255,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255],a:[255,255,255,255,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,252],b:[90,198,53,216,170,58,147,231,179,235,189,85,118,152,134,188,101,29,6,176,204,83,176,246,59,206,60,62,39,210,96,75],order:[255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81],gx:[107,23,209,242,225,44,66,71,248,188,230,229,99,164,64,242,119,3,125,129,45,235,51,160,244,161,57,69,216,152,194,150],gy:[79,227,66,226,254,26,127,155,142,231,235,74,124,15,158,22,43,206,51,87,107,49,94,206,203,182,64,104,55,191,81,245],cf:1};var curve_P384={name:"P-384",type:0,p:[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255],a:[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,252],b:[179,49,47,167,226,62,231,228,152,142,5,107,227,248,45,25,24,29,156,110,254,129,65,18,3,20,8,143,80,19,135,90,198,86,57,141,138,46,209,157,42,133,200,237,211,236,42,239],order:[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115],gx:[170,135,202,34,190,139,5,55,142,177,199,30,243,32,173,116,110,29,59,98,139,167,155,152,89,247,65,224,130,84,42,56,85,2,242,93,191,85,41,108,58,84,94,56,114,118,10,183],gy:[54,23,222,74,150,38,44,111,93,158,152,191,146,146,220,41,248,244,29,189,40,154,20,124,233,218,49,19,181,240,184,192,10,96,177,206,29,126,129,157,122,67,29,124,144,234,14,95],cf:1};var curve_P521={name:"P-521",type:0,p:[16,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],a:[16,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,252],b:[81,149,62,185,97,142,28,154,31,146,154,33,160,182,133,64,238,162,218,114,91,153,179,21,243,184,180,137,145,142,241,144,225,86,25,57,81,236,126,147,123,22,82,192,189,59,177,191,112,53,115,223,136,61,44,52,241,239,69,31,212,107,80,63,0],order:[16,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,16,72,247,144,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,144],gx:[198,133,142,96,183,64,64,233,205,158,62,203,102,35,149,180,66,156,100,129,57,80,63,181,33,248,40,175,96,107,77,61,186,161,75,94,119,239,231,89,40,254,29,193,39,162,255,168,222,51,72,179,193,133,106,66,155,249,126,126,49,194,229,189,102],gy:[16,24,57,41,106,120,154,59,192,64,92,138,95,180,44,125,27,217,152,245,68,73,87,155,68,104,23,175,189,23,39,62,102,44,151,238,114,153,94,244,38,64,197,80,185,16,63,173,112,97,53,60,112,134,162,114,194,64,136,190,148,118,159,209,102,80],cf:1};if(typeof cryptoECC!=="undefined"){cryptoECC.curves["P-256"]=curve_P256;cryptoECC.curves["P-384"]=curve_P384;cryptoECC.curves["P-521"]=curve_P521}var curve_BN254={name:"BN-254",type:0,p:[37,35,100,130,64,0,0,1,186,52,77,128,0,0,0,8,97,33,0,0,0,0,0,19,167,0,0,0,0,0,0,19],a:[0],b:[2],order:[37,35,100,130,64,0,0,1,186,52,77,128,0,0,0,7,255,159,128,0,0,0,0,16,161,0,0,0,0,0,0,13],gx:[37,35,100,130,64,0,0,1,186,52,77,128,0,0,0,8,97,33,0,0,0,0,0,19,167,0,0,0,0,0,0,18],gy:[1],cf:1};if(typeof cryptoECC!=="undefined"){cryptoECC.curves["BN-254"]=curve_BN254}var curve_numsp256d1={info:["numsp256d1",256,256,256],type:0,p:[67,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),a:[64,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),b:[129,85,2].reverse(),order:[37,168,81,71,41,32,171,32,96,92,38,234,117,130,60,228,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),gx:[177,172,26,178,30,238,82,188,58,199,212,3,9,155,87,131,9,203,66,79,160,149,122,41,97,219,170,90,182,214,158,188].reverse(),gy:[159,222,132,33,203,185,181,128,187,15,49,21,209,195,85,201,53,224,4,126,247,139,68,115,166,182,153,51,241,192,143,208].reverse(),cf:1};var curve_numsp256t1={info:["numsp256t1",256,255,256],name:"numsp256t1",type:1,p:[67,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),a:[1],d:[85,195,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),order:[245,74,221,238,144,177,71,26,155,67,89,47,165,90,149,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64].reverse(),gx:[218,19,237,46,144,192,222,160,134,53,8,227,14,138,57,12,214,155,32,105,95,61,30,205,125,35,234,106,251,20,117,138].reverse(),gy:[230,137,138,121,231,22,166,47,211,110,133,16,216,97,95,113,16,128,75,166,217,101,150,206,199,37,217,217,159,62,213,68].reverse(),
cf:4};var curve_numsp384d1={info:["numsp384d1",384,384,384],name:"numsp384d1",type:0,p:[195,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),a:[192,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),b:[187,119,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),order:[185,97,14,123,246,129,77,96,122,226,55,76,61,157,218,190,129,104,93,235,30,175,30,214,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),gx:[42,21,152,32,4,186,156,235,123,196,97,15,16,237,46,82,66,199,108,42,27,41,189,243,244,249,129,251,205,193,37,2,166,241,5,65,34,202,128,72,28,24,111,177,240,86,121,117].reverse(),gy:[22,7,24,102,236,184,116,92,38,173,244,191,219,180,214,188,126,131,26,18,125,131,32,185,156,115,127,248,119,105,4,176,126,207,132,5,48,61,227,215,56,142,155,225,104,227,222,172].reverse(),cf:1};var curve_numsp384t1={info:["numsp384t1",384,382,384],name:"numsp384t1",type:1,p:[195,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),a:[1],d:[159,209,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse(),order:[125,137,163,230,196,220,185,32,121,200,53,171,90,85,228,97,207,225,107,180,28,26,71,226,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63].reverse(),gx:[222,107,32,108,228,64,213,80,19,148,69,101,177,146,242,111,64,99,49,243,168,255,99,87,0,76,190,229,70,244,11,179,181,93,229,154,18,162,182,192,108,38,169,69,251,17,177,97].reverse(),gy:[146,147,114,240,225,3,141,157,220,72,236,70,249,176,114,0,75,150,69,246,247,152,15,131,86,95,66,241,116,130,173,22,215,13,177,35,164,177,56,135,176,238,166,185,103,62,152,130].reverse(),cf:4};if(typeof cryptoECC!=="undefined"){cryptoECC.curves["NUMSP256D1"]=curve_numsp256d1;cryptoECC.curves["NUMSP384D1"]=curve_numsp384d1;cryptoECC.curves["NUMSP256T1"]=curve_numsp256t1;cryptoECC.curves["NUMSP384T1"]=curve_numsp384t1}function BlockFunctionTypeDef(message,blockIndex,initialHashValues,k,w){return[]}var msrcryptoSha=function(name,der,h,k,blockBytes,blockFunction,truncateTo){var utils=msrcryptoUtilities;var hv=h.slice(),w=new Array(blockBytes),buffer=[],blocksProcessed=0;function hashBlocks(message){var blockCount=Math.floor(message.length/blockBytes);for(var block=0;block<blockCount;block++){blockFunction(message,block,hv,k,w)}blocksProcessed+=blockCount;return message.slice(blockCount*blockBytes)}function hashToBytes(){var hash=[];for(var i=0;i<hv.length;i++){hash=hash.concat(utils.int32ToBytes(hv[i]))}hash.length=truncateTo/8;return hash}function addPadding(messageBytes){var padLen=blockBytes-messageBytes.length%blockBytes;padLen<=blockBytes/8&&(padLen+=blockBytes);var padding=utils.getVector(padLen);padding[0]=128;var messageLenBits=(messageBytes.length+blocksProcessed*blockBytes)*8;padding[padLen-4]=messageLenBits>>>24&255;padding[padLen-3]=messageLenBits>>>16&255;padding[padLen-2]=messageLenBits>>>8&255;padding[padLen-1]=messageLenBits&255;return messageBytes.concat(padding)}function computeHash(messageBytes){buffer=hashBlocks(messageBytes);return finish()}function process(messageBytes){buffer=buffer.concat(messageBytes);if(buffer.length>=blockBytes){buffer=hashBlocks(buffer)}return}function finish(){if(hashBlocks(addPadding(buffer)).length!==0){throw new Error("buffer.length !== 0")}var result=hashToBytes();buffer=[];hv=h.slice();blocksProcessed=0;return result}return{name:name,computeHash:computeHash,process:process,finish:finish,der:der,hashLen:truncateTo,maxMessageSize:4294967295}};var msrcryptoSha1=function(){function hashBlock(message,blockIndex,hv,k,w){var t,i,temp,x0,blockSize=64,mask=4294967295;var ra=hv[0],rb=hv[1],rc=hv[2],rd=hv[3],re=hv[4];for(i=0;i<16;i++){w[i]=utils.bytesToInt32(message,blockIndex*blockSize+i*4)}for(t=16;t<80;t++){x0=w[t-3]^w[t-8]^w[t-14]^w[t-16];w[t]=x0<<1|x0>>>31}for(i=0;i<80;i++){temp=ra<<5|ra>>>27;temp+=i>=60?rb^rc^rd:i>=40?rb&rc^rb&rd^rc&rd:i>=20?rb^rc^rd:rb&rc^~rb&rd;temp+=re+k[i]+w[i];re=rd;rd=rc;rc=rb<<30|rb>>>2;rb=ra;ra=temp}hv[0]+=ra&mask;hv[1]+=rb&mask;hv[2]+=rc&mask;hv[3]+=rd&mask;hv[4]+=re&mask;return hv}var utils=msrcryptoUtilities,upd=utils.unpackData,h=upd("Z0UjAe/Nq4mYutz+EDJUdsPS4fA=",4,1),k=upd("WoJ5mVqCeZlagnmZWoJ5mVqCeZlagnmZWoJ5mVqCeZlagnmZWoJ5mVqCeZlagnmZWoJ5mVqCeZlagnmZWoJ5mVqCeZlagnmZWoJ5mVqCeZlu2euhbtnroW7Z66Fu2euhbtnroW7Z66Fu2euhbtnroW7Z66Fu2euhbtnroW7Z66Fu2euhbtnroW7Z66Fu2euhbtnroW7Z66Fu2euhbtnroY8bvNyPG7zcjxu83I8bvNyPG7zcjxu83I8bvNyPG7zcjxu83I8bvNyPG7zcjxu83I8bvNyPG7zcjxu83I8bvNyPG7zcjxu83I8bvNyPG7zcymLB1spiwdbKYsHWymLB1spiwdbKYsHWymLB1spiwdbKYsHWymLB1spiwdbKYsHWymLB1spiwdbKYsHWymLB1spiwdbKYsHWymLB1spiwdY",4,1),der=upd("MCEwCQYFKw4DAhoFAAQU");return{sha1:msrcryptoSha("SHA-1",der,h,k,64,hashBlock,160)}}();if(typeof operations!=="undefined"){msrcryptoSha1.hash=function(p){if(p.operationSubType==="process"){msrcryptoSha1.sha1.process(p.buffer);return}if(p.operationSubType==="finish"){return msrcryptoSha1.sha1.finish()}return msrcryptoSha1.sha1.computeHash(p.buffer)};operations.register("digest","sha-1",msrcryptoSha1.hash)}msrcryptoHashFunctions["sha-1"]=msrcryptoSha1.sha1;var msrcryptoSha256=function(){var utils=msrcryptoUtilities;function hashBlock(message,blockIndex,hv,k,w){var t,i,temp,x0,x1,blockSize=64,mask=4294967295;var ra=hv[0],rb=hv[1],rc=hv[2],rd=hv[3],re=hv[4],rf=hv[5],rg=hv[6],rh=hv[7];for(i=0;i<16;i++){w[i]=utils.bytesToInt32(message,blockIndex*blockSize+i*4)}for(t=16;t<64;t++){x0=w[t-15];x1=w[t-2];w[t]=((x1>>>17|x1<<15)^(x1>>>19|x1<<13)^x1>>>10)+w[t-7]+((x0>>>7|x0<<25)^(x0>>>18|x0<<14)^x0>>>3)+w[t-16];w[t]=w[t]&mask}for(i=0;i<64;i++){temp=rh+((re>>>6|re<<26)^(re>>>11|re<<21)^(re>>>25|re<<7))+(re&rf^~re&rg)+k[i]+w[i];rd+=temp;temp+=((ra>>>2|ra<<30)^(ra>>>13|ra<<19)^(ra>>>22|ra<<10))+(ra&(rb^rc)^rb&rc);rh=rg;rg=rf;rf=re;re=rd;rd=rc;rc=rb;rb=ra;ra=temp}hv[0]+=ra&mask;hv[1]+=rb&mask;hv[2]+=rc&mask;hv[3]+=rd&mask;hv[4]+=re&mask;hv[5]+=rf&mask;hv[6]+=rg&mask;hv[7]+=rh&mask;return hv}var k256,h224,h256,der224,der256,upd=utils.unpackData;h224=upd("wQWe2DZ81QcwcN0X9w5ZOf/ACzFoWBURZPmPp776T6Q",4,1);h256=upd("agnmZ7tnroU8bvNypU/1OlEOUn+bBWiMH4PZq1vgzRk",4,1);k256=upd("QoovmHE3RJG1wPvP6bXbpTlWwltZ8RHxkj+CpKscXtXYB6qYEoNbASQxhb5VDH3Dcr5ddIDesf6b3AanwZvxdOSbacHvvkeGD8GdxiQMocwt6SxvSnSEqlywqdx2+YjamD5RUqgxxm2wAyfIv1l/x8bgC/PVp5FHBspjURQpKWcntwqFLhshOE0sbfxTOA0TZQpzVHZqCruBwskuknIshaK/6KGoGmZLwkuLcMdsUaPRkugZ1pkGJPQONYUQaqBwGaTBFh43bAgnSHdMNLC8tTkcDLNO2KpKW5zKT2gub/N0j4LueKVjb4TIeBSMxwIIkL7/+qRQbOu++aP3xnF48g",4,1);der224=upd("MC0wDQYJYIZIAWUDBAIEBQAEHA");der256=upd("MDEwDQYJYIZIAWUDBAIBBQAEIA");return{sha224:msrcryptoSha("SHA-224",der224,h224,k256,64,hashBlock,224),sha256:msrcryptoSha("SHA-256",der256,h256,k256,64,hashBlock,256)}}();if(typeof operations!=="undefined"){msrcryptoSha256.hash256=function(p){if(p.operationSubType==="process"){msrcryptoSha256.sha256.process(p.buffer);return}if(p.operationSubType==="finish"){return msrcryptoSha256.sha256.finish()}return msrcryptoSha256.sha256.computeHash(p.buffer)};msrcryptoSha256.hash224=function(p){if(p.operationSubType==="process"){msrcryptoSha256.sha224.process(p.buffer);return}if(p.operationSubType==="finish"){return msrcryptoSha256.sha224.finish()}return msrcryptoSha256.sha224.computeHash(p.buffer)};operations.register("digest","sha-224",msrcryptoSha256.hash224);operations.register("digest","sha-256",msrcryptoSha256.hash256)}msrcryptoHashFunctions["sha-224"]=msrcryptoSha256.sha224;msrcryptoHashFunctions["sha-256"]=msrcryptoSha256.sha256;var msrcryptoSha512=function(){var utils=msrcryptoUtilities;function add(x0,x1,y0,y1,resultArray){var lowSum=x1+y1|0;var carry=lowSum>>>0<y1>>>0;resultArray[0]=x0+y0+carry|0;resultArray[1]=lowSum;return}function hashBlock(message,blockIndex,hv,k,w){var t,i,blockBytes=128,tah,tal,tbh,tbl,xh,xl,tc=[],td=[],te=[],index;var ah=hv[0],al=hv[1],bh=hv[2],bl=hv[3],ch=hv[4],cl=hv[5],dh=hv[6],dl=hv[7],eh=hv[8],el=hv[9],fh=hv[10],fl=hv[11],gh=hv[12],gl=hv[13],hh=hv[14],hl=hv[15];for(t=0;t<32;t++){index=blockIndex*blockBytes+t*4;w[t]=message.slice(index,index+4);w[t]=w[t][0]<<24|w[t][1]<<16|w[t][2]<<8|w[t][3]}for(t=32;t<160;t+=2){xh=w[t-30];xl=w[t-29];tah=(xh>>>1|xl<<31)^(xh>>>8|xl<<24)^xh>>>7;tal=(xl>>>1|xh<<31)^(xl>>>8|xh<<24)^(xl>>>7|xh<<25);xh=w[t-4];xl=w[t-3];tbh=(xh>>>19|xl<<13)^(xl>>>29|xh<<3)^xh>>>6;tbl=(xl>>>19|xh<<13)^(xh>>>29|xl<<3)^(xl>>>6|xh<<26);add(tbh,tbl,w[t-14],w[t-13],tc);add(tah,tal,tc[0],tc[1],tc);add(w[t-32],w[t-31],tc[0],tc[1],tc);w[t]=tc[0];w[t+1]=tc[1]}for(i=0;i<160;i+=2){tah=(eh>>>14|el<<18)^(eh>>>18|el<<14)^(el>>>9|eh<<23);tal=(el>>>14|eh<<18)^(el>>>18|eh<<14)^(eh>>>9|el<<23);tbh=eh&fh^gh&~eh;tbl=el&fl^gl&~el;add(hh,hl,tah,tal,tc);add(tbh,tbl,k[i],k[i+1],td);add(tc[0],tc[1],w[i],w[i+1],te);add(td[0],td[1],te[0],te[1],te);add(te[0],te[1],dh,dl,tc);dh=tc[0];dl=tc[1];tal=(al>>>28|ah<<4)^(ah>>>2|al<<30)^(ah>>>7|al<<25);tah=(ah>>>28|al<<4)^(al>>>2|ah<<30)^(al>>>7|ah<<25);tbl=al&(bl^cl)^bl&cl;tbh=ah&(bh^ch)^bh&ch;add(te[0],te[1],tah,tal,tc);tah=tc[0];tal=tc[1];add(tbh,tbl,tah,tal,tc);tah=tc[0];tal=tc[1];hh=gh;hl=gl;gh=fh;gl=fl;fh=eh;fl=el;eh=dh;el=dl;dh=ch;dl=cl;ch=bh;cl=bl;bh=ah;bl=al;ah=tah;al=tal}add(hv[0],hv[1],ah,al,tc);hv[0]=tc[0];hv[1]=tc[1];add(hv[2],hv[3],bh,bl,tc);hv[2]=tc[0];hv[3]=tc[1];add(hv[4],hv[5],ch,cl,tc);hv[4]=tc[0];hv[5]=tc[1];add(hv[6],hv[7],dh,dl,tc);hv[6]=tc[0];hv[7]=tc[1];add(hv[8],hv[9],eh,el,tc);hv[8]=tc[0];hv[9]=tc[1];add(hv[10],hv[11],fh,fl,tc);hv[10]=tc[0];hv[11]=tc[1];add(hv[12],hv[13],gh,gl,tc);hv[12]=tc[0];hv[13]=tc[1];add(hv[14],hv[15],hh,hl,tc);hv[14]=tc[0];hv[15]=tc[1];return hv}var h384,h512,k512,der384,der512,der512_224,der512_256,upd=utils.unpackData;h384=upd("y7udXcEFnthimikqNnzVB5FZAVowcN0XFS/s2PcOWTlnMyZn/8ALMY60SodoWBUR2wwuDWT5j6dHtUgdvvpPpA==",4,1);h512=upd("agnmZ/O8yQi7Z66FhMqnOzxu83L+lPgrpU/1Ol8dNvFRDlJ/reaC0ZsFaIwrPmwfH4PZq/tBvWtb4M0ZE34heQ",4,1);k512=upd("QoovmNcoriJxN0SRI+9lzbXA+8/sTTsv6bXbpYGJ27w5VsJb80i1OFnxEfG2BdAZkj+CpK8ZT5urHF7"+"V2m2BGNgHqpijAwJCEoNbAUVwb74kMYW+TuSyjFUMfcPV/7Ticr5ddPJ7iW+A3rH+OxaWsZvcBqclxx"+"I1wZvxdM9pJpTkm2nBnvFK0u++R4Y4TyXjD8GdxouM1bUkDKHMd6ycZS3pLG9ZKwJ1SnSEqm6m5INcs"+"KncvUH71Hb5iNqDEVO1mD5RUu5m36uoMcZtLbQyELADJ8iY+yE/v1l/x77vDuTG4AvzPaiPwtWnkUeT"+"CqclBspjUeADgm8UKSlnCg5ucCe3CoVG0i/8LhshOFwmySZNLG38WsQq7VM4DROdlbPfZQpzVIuvY95"+"2agq7PHeyqIHCyS5H7a7mknIshRSCNTuiv+ihTPEDZKgaZku8QjABwkuLcND4l5HHbFGjBlS+MNGS6B"+"nW71IY1pkGJFVlqRD0DjWFV3EgKhBqoHAyu9G4GaTBFrjS0MgeN2wIUUGrUydId0zfjuuZNLC8teGbS"+"Kg5HAyzxclaY07YqkrjQYrLW5zKT3dj43NoLm/z1rK4o3SPgu5d77L8eKVjb0MXL2CEyHgUofCrcozH"+"AggaZDnskL7/+iNjHiikUGzr3oK96b75o/eyxnkVxnF48uNyUyvKJz7O6iZhnNGGuMchwMIH6tp91s3"+"g6x71fU9/7m7ReAbwZ6pyF2+6CmN9xaLImKYRP5gEvvkNrhtxCzUTHEcbKNt39SMEfYQyyqt7QMckkz"+"yevgoVyb68Qx1nxJwQDUxMxdS+yz5Ctll/KZz8ZX4qX8tvqzrW+uxsRBmMSkdYFw==",4,1);der384=upd("MEEwDQYJYIZIAWUDBAICBQAEMA");der512=upd("MFEwDQYJYIZIAWUDBAIDBQAEQA");der512_224=upd("MC0wDQYJYIZIAWUDBAIFBQAEHA");der512_256=upd("MDEwDQYJYIZIAWUDBAIGBQAEIA");return{sha384:msrcryptoSha("SHA-384",der384,h384,k512,128,hashBlock,384),sha512:msrcryptoSha("SHA-512",der512,h512,k512,128,hashBlock,512),sha512_224:msrcryptoSha("SHA-512.224",der512_224,h512,k512,128,hashBlock,224),sha512_256:msrcryptoSha("SHA-512.256",der512_256,h512,k512,128,hashBlock,256)}}();if(typeof operations!=="undefined"){msrcryptoSha512.hash384=function(p){if(p.operationSubType==="process"){msrcryptoSha512.sha384.process(p.buffer);return}if(p.operationSubType==="finish"){return msrcryptoSha512.sha384.finish()}return msrcryptoSha512.sha384.computeHash(p.buffer)};msrcryptoSha512.hash512=function(p){if(p.operationSubType==="process"){msrcryptoSha512.sha512.process(p.buffer);return}if(p.operationSubType==="finish"){return msrcryptoSha512.sha512.finish()}return msrcryptoSha512.sha512.computeHash(p.buffer)};operations.register("digest","sha-384",msrcryptoSha512.hash384);operations.register("digest","sha-512",msrcryptoSha512.hash512)}msrcryptoHashFunctions["sha-384"]=msrcryptoSha512.sha384;msrcryptoHashFunctions["sha-512"]=msrcryptoSha512.sha512;var msrcryptoHmac=function(){var sha256,sha512,sha1;if(typeof msrcryptoSha256!=="undefined"){sha256=msrcryptoSha256}if(typeof msrcryptoSha512!=="undefined"){sha512=msrcryptoSha512}if(typeof msrcryptoSha1!=="undefined"){sha1=msrcryptoSha1}var hashFunction;var blockSize;var keyBytes;var ipad;var opad;function xorArrays(array1,array2){var newArray=new Array(array1);for(var i=0;i<array1.length;i++){newArray[i]=array1[i]^array2[i]}return newArray}function padZeros(bytes,paddedLength){var paddedArray=bytes.slice();for(var i=bytes.length;i<paddedLength;i++){paddedArray.push(0)}return paddedArray}function padKey(){if(keyBytes.length===blockSize){return keyBytes}if(keyBytes.length>blockSize){return padZeros(hashFunction.computeHash(keyBytes),blockSize)}return padZeros(keyBytes,blockSize)}var paddedKey=null;var keyXorOpad;function processHmac(messageBytes){var keyXorIpad;var k0IpadText;if(!paddedKey){ipad=new Array(blockSize);opad=new Array(blockSize);for(var i=0;i<blockSize;i++){ipad[i]=54;opad[i]=92}paddedKey=padKey();keyXorIpad=xorArrays(paddedKey,ipad);keyXorOpad=xorArrays(paddedKey,opad);k0IpadText=keyXorIpad.concat(messageBytes);hashFunction.process(k0IpadText)}else{hashFunction.process(messageBytes)}return}function finishHmac(){var hashK0IpadText=hashFunction.finish();var k0IpadK0OpadText=keyXorOpad.concat(hashK0IpadText);return hashFunction.computeHash(k0IpadK0OpadText)}function clearState(){keyBytes=null;hashFunction=null;paddedKey=null}function selectHashAlgorithm(hashAlgorithmName){switch(hashAlgorithmName.toLowerCase()){case"sha-1":if(sha1===undefined){throw new Error("Sha1 object not found")}hashFunction=sha1.sha1;blockSize=64;break;case"sha-224":hashFunction=sha256.sha224;blockSize=64;break;case"sha-256":hashFunction=sha256.sha256;blockSize=64;break;case"sha-384":if(sha512===undefined){throw new Error("Sha512 object not found")}hashFunction=sha512.sha384;blockSize=128;break;case"sha-512":if(sha512===undefined){throw new Error("Sha512 object not found")}hashFunction=sha512.sha512;blockSize=128;break;default:throw new Error("unsupported hash alorithm (sha-224, sha-256, sha-384, sha-512)")}}return{computeHmac:function(dataBytes,key,hashAlgorithm){keyBytes=key;selectHashAlgorithm(hashAlgorithm);processHmac(dataBytes);var result=finishHmac();clearState();return result},process:function(dataBytes,key,hashAlgorithm){if(!hashFunction){keyBytes=key;selectHashAlgorithm(hashAlgorithm)}processHmac(dataBytes)},finish:function(key,hashAlgorithm){if(!hashFunction){keyBytes=key;selectHashAlgorithm(hashAlgorithm);processHmac([])}var result=finishHmac();clearState();return result}}}();if(typeof operations!=="undefined"){msrcryptoHmac.signHmac=function(p){var hashName=p.algorithm.hash.name;if(p.operationSubType==="process"){msrcryptoHmac.process(p.buffer,p.keyData,hashName);return}if(p.operationSubType==="finish"){return msrcryptoHmac.finish(p.keyData,hashName)}return msrcryptoHmac.computeHmac(p.buffer,p.keyData,hashName)};msrcryptoHmac.verifyHmac=function(p){var hashName=p.algorithm.hash.name;if(p.operationSubType==="process"){msrcryptoHmac.process(p.buffer,p.keyData,hashName);return}if(p.operationSubType==="finish"){return msrcryptoUtilities.arraysEqual(msrcryptoHmac.finish(p.keyData,hashName),p.signature)}return msrcryptoUtilities.arraysEqual(msrcryptoHmac.computeHmac(p.buffer,p.keyData,hashName),p.signature)};msrcryptoHmac.generateKey=function(p){var keyLength=p.algorithm.length;var defaultKeyLengths={"sha-256":32,"sha-384":48,"sha-512":64};if(!keyLength){keyLength=defaultKeyLengths[p.algorithm.hash.name.toLowerCase()]}return{type:"keyGeneration",keyData:msrcryptoPseudoRandom.getBytes(keyLength),keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoHmac.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["k"]);keyObject.alg=keyObject.alg.replace("HS","sha-");return{type:"keyImport",keyData:keyObject.k,keyHandle:{algorithm:{name:"hmac",hash:{name:keyObject.alg}},extractable:p.extractable||keyObject.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoHmac.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("importKey","hmac",msrcryptoHmac.importKey);operations.register("exportKey","hmac",msrcryptoHmac.exportKey);operations.register("generateKey","hmac",msrcryptoHmac.generateKey);operations.register("sign","hmac",msrcryptoHmac.signHmac);operations.register("verify","hmac",msrcryptoHmac.verifyHmac)}var msrcryptoBlockCipher=function(){var aesConstants,multByTwo,multByThree,multBy14,multBy13,multBy11,multBy9,sBoxTable,invSBoxTable,rConTable;return{aes:function(keyBytes){if(!aesConstants){aesConstants=msrcryptoUtilities.unpackData("AAIEBggKDA4QEhQWGBocHiAiJCYoKiwuMDI0Njg6PD5AQkRGSEpMTlBSVFZYWlxeYGJkZmhqbG5wcnR2eHp8foCChIaIioyOkJKUlpianJ6goqSmqKqsrrCytLa4ury+wMLExsjKzM7Q0tTW2Nrc3uDi5Obo6uzu8PL09vj6/P4bGR8dExEXFQsJDw0DAQcFOzk/PTMxNzUrKS8tIyEnJVtZX11TUVdVS0lPTUNBR0V7eX99c3F3dWtpb21jYWdlm5mfnZORl5WLiY+Ng4GHhbu5v72zsbe1q6mvraOhp6Xb2d/d09HX1cvJz83DwcfF+/n//fPx9/Xr6e/t4+Hn5QADBgUMDwoJGBseHRQXEhEwMzY1PD86OSgrLi0kJyIhYGNmZWxvaml4e359dHdycVBTVlVcX1pZSEtOTURHQkHAw8bFzM/Kydjb3t3U19LR8PP29fz/+vno6+7t5Ofi4aCjpqWsr6qpuLu+vbS3srGQk5aVnJ+amYiLjo2Eh4KBm5idnpeUkZKDgIWGj4yJiquora6npKGis7C1tr+8ubr7+P3+9/Tx8uPg5ebv7Onqy8jNzsfEwcLT0NXW39zZ2ltYXV5XVFFSQ0BFRk9MSUpraG1uZ2RhYnNwdXZ/fHl6Ozg9Pjc0MTIjICUmLywpKgsIDQ4HBAECExAVFh8cGRoADhwSODYkKnB+bGJIRlRa4O788tjWxMqQnoyCqKa0utvVx8nj7f/xq6W3uZOdj4E7NScpAw0fEUtFV1lzfW9hraOxv5WbiYfd08HP5ev5901DUV91e2lnPTMhLwULGRd2eGpkTkBSXAYIGhQ+MCIslpiKhK6gsrzm6Pr03tDCzEFPXVN5d2VrMT8tIwkHFRuhr72zmZeFi9HfzcPp5/X7mpSGiKKsvrDq5Pb40tzOwHp0ZmhCTF5QCgQWGDI8LiDs4vD+1NrIxpySgI6kqri2DAIQHjQ6KCZ8cmBuREpYVjc5KyUPARMdR0lbVX9xY23X2cvF7+Hz/aepu7WfkYONAA0aFzQ5LiNoZXJ/XFFGS9Ddysfk6f7zuLWir4yBlpu7tqGsj4KVmNPeycTn6v3wa2ZxfF9SRUgDDhkUNzotIG1gd3pZVENOBQgfEjE8Kya9sKeqiYSTntXYz8Lh7Pv21tvMweLv+PW+s6SpioeQnQYLHBEyPyglbmN0eVpXQE3a18DN7uP0+bK/qKWGi5yRCgcQHT4zJClib3h1VltMQWFse3ZVWE9CCQQTHj0wJyqxvKumhYifktnUw87t4Pf6t7qtoIOOmZTf0sXI6+bx/GdqfXBTXklEDwIVGDs2ISwMARYbODUiL2RpfnNQXUpH3NHGy+jl8v+0ua6jgI2alwALFh0sJzoxWFNORXR/Ymmwu6atnJeKgejj/vXEz9LZe3BtZldcQUojKDU+DwQZEsvA3dbn7PH6k5iFjr+0qaL2/eDr2tHMx66luLOCiZSfRk1QW2phfHceFQgDMjkkL42Gm5Chqre81d7DyPny7+Q9NisgERoHDGVuc3hJQl9U9/zh6tvQzcavpLmyg4iVnkdMUVprYH12HxQJAjM4JS6Mh5qRoKu2vdTfwsn48+7lPDcqIRAbBg1kb3J5SENeVQEKFxwtJjswWVJPRHV+Y2ixuqesnZaLgOni//TFztPYenFsZ1ZdQEsiKTQ/DgUYE8rB3Nfm7fD7kpmEj761qKMACRIbJC02P0hBWlNsZX53kJmCi7S9pq/Y0crD/PXu5zsyKSAfFg0Ec3phaFdeRUyrormwj4adlOPq8fjHztXcdn9kbVJbQEk+NywlGhMIAebv9P3Cy9DZrqe8tYqDmJFNRF9WaWB7cgUMFx4hKDM63dTPxvnw6+KVnIeOsbijquzl/vfIwdrTpK22v4CJkpt8dW5nWFFKQzQ9Ji8QGQIL197FzPP64eiflo2Eu7KpoEdOVVxjanF4DwYdFCsiOTCak4iBvrespdLbwMn2/+TtCgMYES4nPDVCS1BZZm90faGos7qFjJee6eD78s3E39YxOCMqFRwHDnlwa2JdVE9GY3x3e/Jrb8UwAWcr/terdsqCyX36WUfwrdSir5ykcsC3/ZMmNj/3zDSl5fFx2DEVBMcjwxiWBZoHEoDi6yeydQmDLBobblqgUjvWsynjL4RT0QDtIPyxW2rLvjlKTFjP0O+q+0NNM4VF+QJ/UDyfqFGjQI+SnTj1vLbaIRD/89LNDBPsX5dEF8Snfj1kXRlzYIFP3CIqkIhG7rgU3l4L2+AyOgpJBiRcwtOsYpGV5HnnyDdtjdVOqWxW9Opleq4IunglLhymtMbo3XQfS72LinA+tWZIA/YOYTVXuYbBHZ7h+JgRadmOlJseh+nOVSjfjKGJDb/mQmhBmS0PsFS7FlIJatUwNqU4v0CjnoHz1/t84zmCmy//hzSOQ0TE3unLVHuUMqbCIz3uTJULQvrDTgguoWYo2SSydluiSW2L0SVy+PZkhmiYFtSkXMxdZbaSbHBIUP3tudpeFUZXp42dhJDYqwCMvNMK9+RYBbizRQbQLB6Pyj8PAsGvvQMBE4prOpERQU9n3OqX8s/O8LTmc5asdCLnrTWF4vk36Bx1325H8RpxHSnFiW+3Yg6qGL4b/FY+S8bSeSCa28D+eM1a9B/dqDOIB8cxsRIQWSeA7F9gUX+pGbVKDS3lep+TyZzvoOA7Ta4q9bDI67s8g1OZYRcrBH66d9Ym4WkUY1UhDH2NAQIECBAgQIAbNmzYq02aL168Y8aXNWrUs33678WROXLk071hwp8lSpQzZsyDHTp06MuNAQIECBAgQIAbNmzYq02aL168Y8aXNWrUs33678WROXLk071hwp8lSpQzZsyDHTp06MuNAQIECBAgQIAbNmzYq02aL168Y8aXNWrUs33678WROXLk071hwp8lSpQzZsyDHTp06MuNAQIECBAgQIAbNmzYq02aL168Y8aXNWrUs33678WROXLk071hwp8lSpQzZsyDHTp06MuNAQIECBAgQIAbNmzYq02aL168Y8aXNWrUs33678WROXLk071hwp8lSpQzZsyDHTp06MuN",256,false);multByTwo=aesConstants[0];multByThree=aesConstants[1];multBy14=aesConstants[2];multBy13=aesConstants[3];multBy11=aesConstants[4];multBy9=aesConstants[5];sBoxTable=aesConstants[6];invSBoxTable=aesConstants[7];rConTable=aesConstants[8]}var blockSize=128,keyLength,nK,nB=4,nR,key;switch(keyBytes.length*8){case 128:keyLength=128;nK=4;nR=10;break;case 192:keyLength=192;nK=6;nR=12;break;case 256:keyLength=256;nK=8;nR=14;break;default:throw new Error("Unsupported keyLength")}var shiftRows=function(a){var tmp=a[1];a[1]=a[5];a[5]=a[9];a[9]=a[13];a[13]=tmp;tmp=a[2];a[2]=a[10];a[10]=tmp;tmp=a[6];a[6]=a[14];a[14]=tmp;tmp=a[15];a[15]=a[11];a[11]=a[7];a[7]=a[3];a[3]=tmp};var invShiftRows=function(a){var tmp=a[13];a[13]=a[9];a[9]=a[5];a[5]=a[1];a[1]=tmp;tmp=a[10];a[10]=a[2];a[2]=tmp;tmp=a[14];a[14]=a[6];a[6]=tmp;tmp=a[3];a[3]=a[7];a[7]=a[11];a[11]=a[15];a[15]=tmp};var mixColumns=function(state){var a=state[0],b=state[1],c=state[2],d=state[3],e=state[4],f=state[5],g=state[6],h=state[7],i=state[8],j=state[9],k=state[10],l=state[11],m=state[12],n=state[13],o=state[14],p=state[15];state[0]=multByTwo[a]^multByThree[b]^c^d;state[1]=a^multByTwo[b]^multByThree[c]^d;state[2]=a^b^multByTwo[c]^multByThree[d];state[3]=multByThree[a]^b^c^multByTwo[d];state[4]=multByTwo[e]^multByThree[f]^g^h;state[5]=e^multByTwo[f]^multByThree[g]^h;state[6]=e^f^multByTwo[g]^multByThree[h];state[7]=multByThree[e]^f^g^multByTwo[h];state[8]=multByTwo[i]^multByThree[j]^k^l;state[9]=i^multByTwo[j]^multByThree[k]^l;state[10]=i^j^multByTwo[k]^multByThree[l];state[11]=multByThree[i]^j^k^multByTwo[l];state[12]=multByTwo[m]^multByThree[n]^o^p;state[13]=m^multByTwo[n]^multByThree[o]^p;state[14]=m^n^multByTwo[o]^multByThree[p];state[15]=multByThree[m]^n^o^multByTwo[p]};var invMixColumns=function(state){var a=state[0],b=state[1],c=state[2],d=state[3],e=state[4],f=state[5],g=state[6],h=state[7],i=state[8],j=state[9],k=state[10],l=state[11],m=state[12],n=state[13],o=state[14],p=state[15];state[0]=multBy14[a]^multBy11[b]^multBy13[c]^multBy9[d];state[1]=multBy9[a]^multBy14[b]^multBy11[c]^multBy13[d];state[2]=multBy13[a]^multBy9[b]^multBy14[c]^multBy11[d];state[3]=multBy11[a]^multBy13[b]^multBy9[c]^multBy14[d];state[4]=multBy14[e]^multBy11[f]^multBy13[g]^multBy9[h];state[5]=multBy9[e]^multBy14[f]^multBy11[g]^multBy13[h];state[6]=multBy13[e]^multBy9[f]^multBy14[g]^multBy11[h];state[7]=multBy11[e]^multBy13[f]^multBy9[g]^multBy14[h];state[8]=multBy14[i]^multBy11[j]^multBy13[k]^multBy9[l];state[9]=multBy9[i]^multBy14[j]^multBy11[k]^multBy13[l];state[10]=multBy13[i]^multBy9[j]^multBy14[k]^multBy11[l];state[11]=multBy11[i]^multBy13[j]^multBy9[k]^multBy14[l];state[12]=multBy14[m]^multBy11[n]^multBy13[o]^multBy9[p];state[13]=multBy9[m]^multBy14[n]^multBy11[o]^multBy13[p];state[14]=multBy13[m]^multBy9[n]^multBy14[o]^multBy11[p];state[15]=multBy11[m]^multBy13[n]^multBy9[o]^multBy14[p]};var xorWord=function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]};var addRoundKey=function(state,keySchedule,offset){for(var i=0;i<state.length;i+=1){state[i]^=keySchedule[i+offset]}};var rotWord=function(word){var a=word[0];word[0]=word[1];word[1]=word[2];word[2]=word[3];word[3]=a};var subWord=function(word){for(var i=0;i<word.length;i+=1){word[i]=sBoxTable[word[i]]}};var invSubWord=function(word){for(var i=0;i<word.length;i+=1){word[i]=invSBoxTable[word[i]]}};var getWord=function(tab,i){return[tab[4*i],tab[4*i+1],tab[4*i+2],tab[4*i+3]]};var setWord=function(left,right,indexL,indexR){left[4*indexL]=right[4*indexR];left[4*indexL+1]=right[4*indexR+1];left[4*indexL+2]=right[4*indexR+2];left[4*indexL+3]=right[4*indexR+3]};var expandKey=function(key){var temp,res=[],i=0;while(i<4*nK){res.push(key[i++])}i=nK;while(i<nB*(nR+1)){temp=getWord(res,i-1);if(i%nK===0){var index=i/nK;var rcon=[rConTable[index],0,0,0];rotWord(temp);subWord(temp);temp=xorWord(temp,rcon)}else if(nK>6&&i%nK===4){subWord(temp)}var newWord=xorWord(getWord(res,i-nK),temp);setWord(res,newWord,i,0);i+=1}return res};key=expandKey(keyBytes);return{encrypt:function(dataBytes){var state=dataBytes,round;addRoundKey(state,key,0);for(round=1;round<=nR-1;round+=1){subWord(state);shiftRows(state);mixColumns(state);addRoundKey(state,key,4*round*nB)}subWord(state);shiftRows(state);addRoundKey(state,key,4*nR*nB);return state},decrypt:function(dataBytes){var state=dataBytes,round;addRoundKey(state,key,4*nR*nB);for(round=nR-1;round>=1;round-=1){invShiftRows(state);invSubWord(state);addRoundKey(state,key,4*round*nB);invMixColumns(state)}invShiftRows(state);invSubWord(state);addRoundKey(state,key,0);return state},clear:function(){},keyLength:keyLength,blockSize:blockSize}}}}();var msrcryptoPadding=msrcryptoPadding||{};msrcryptoPadding.pkcsv7=function(blockSize){function pad(messageBlocks){var lastIndex=messageBlocks.length-1>=0?messageBlocks.length-1:0,lastBlock=messageBlocks[lastIndex],lastBlockLength=lastBlock.length,createNewBlock=lastBlockLength===blockSize;if(createNewBlock){var newBlock=[],i;for(i=0;i<blockSize;i+=1){newBlock.push(blockSize)}messageBlocks.push(newBlock)}else{var byteToAdd=blockSize-lastBlockLength&255;while(lastBlock.length!==blockSize){lastBlock.push(byteToAdd)}}}function unpad(messageBytes){var verified=true;if(messageBytes.length%blockSize!==0){verified=false}var lastBlock=messageBytes.slice(-blockSize);var padLen=lastBlock[lastBlock.length-1];for(var i=0;i<blockSize;i++){var isPaddingElement=blockSize-i<=padLen;var isCorrectValue=lastBlock[i]===padLen;verified=(isPaddingElement?isCorrectValue:true)&&verified}var trimLen=verified?padLen:0;messageBytes.length-=trimLen;return verified}return{pad:pad,unpad:unpad}};var msrcryptoCbc=function(blockCipher){var blockSize=blockCipher.blockSize/8;var paddingScheme=msrcryptoPadding.pkcsv7(blockSize);var mergeBlocks=function(tab){var res=[],i,j;for(i=0;i<tab.length;i+=1){var block=tab[i];for(j=0;j<block.length;j+=1){res.push(block[j])}}return res};function getBlocks(dataBytes){var blocks=[];mBuffer=mBuffer.concat(dataBytes);var blockCount=Math.floor(mBuffer.length/blockSize);for(var i=0;i<blockCount;i++){blocks.push(mBuffer.slice(i*blockSize,(i+1)*blockSize))}mBuffer=mBuffer.slice(blockCount*blockSize);return blocks}function encryptBlocks(blocks){var result=[],toEncrypt;for(var i=0;i<blocks.length;i++){toEncrypt=msrcryptoUtilities.xorVectors(mIvBytes,blocks[i]);result.push(blockCipher.encrypt(toEncrypt));mIvBytes=result[i]}return result}function decryptBlocks(blocks){var result=[],toDecrypt,decrypted;for(var i=0;i<blocks.length;i+=1){toDecrypt=blocks[i].slice(0,blocks[i].length);decrypted=blockCipher.decrypt(toDecrypt);result.push(msrcryptoUtilities.xorVectors(mIvBytes,decrypted));mIvBytes=blocks[i]}return result}function clearState(){mBuffer=[];mResultBuffer=[];mIvBytes=null}var mBuffer=[],mResultBuffer=[],mIvBytes;return{init:function(ivBytes){if(ivBytes.length!==blockSize){throw new Error("Invalid iv size")}mIvBytes=ivBytes.slice()},encrypt:function(plainBytes){this.processEncrypt(plainBytes);return this.finishEncrypt()},processEncrypt:function(plainBytes){var result=encryptBlocks(getBlocks(plainBytes));mResultBuffer=mResultBuffer.concat(mergeBlocks(result));return},finishEncrypt:function(){var blocks=mBuffer.length===1?[[mBuffer[0]]]:[mBuffer];paddingScheme.pad(blocks);var result=mResultBuffer.concat(mergeBlocks(encryptBlocks(blocks)));clearState();return result},decrypt:function(cipherBytes){this.processDecrypt(cipherBytes);return this.finishDecrypt()},processDecrypt:function(cipherBytes){var result=decryptBlocks(getBlocks(cipherBytes));mResultBuffer=mResultBuffer.concat(mergeBlocks(result));return},finishDecrypt:function(){var result=mResultBuffer;var verified=paddingScheme.unpad(result);clearState();return result}}};var cbcInstance=null;if(typeof operations!=="undefined"){msrcryptoCbc.workerEncrypt=function(p){var result;if(!cbcInstance){cbcInstance=msrcryptoCbc(msrcryptoBlockCipher.aes(p.keyData));cbcInstance.init(p.algorithm.iv)}if(p.operationSubType==="process"){cbcInstance.processEncrypt(p.buffer);return}if(p.operationSubType==="finish"){result=cbcInstance.finishEncrypt();cbcInstance=null;return result}result=cbcInstance.encrypt(p.buffer);cbcInstance=null;return result};msrcryptoCbc.workerDecrypt=function(p){var result;if(!cbcInstance){cbcInstance=msrcryptoCbc(msrcryptoBlockCipher.aes(p.keyData));cbcInstance.init(p.algorithm.iv)}if(p.operationSubType==="process"){cbcInstance.processDecrypt(p.buffer);return}if(p.operationSubType==="finish"){result=cbcInstance.finishDecrypt();cbcInstance=null;return result}result=cbcInstance.decrypt(p.buffer);cbcInstance=null;return result};msrcryptoCbc.generateKey=function(p){if(p.algorithm.length%8!==0){throw new Error}return{type:"keyGeneration",keyData:msrcryptoPseudoRandom.getBytes(Math.floor(p.algorithm.length/8)),keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoCbc.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["k"]);p.algorithm.length=keyObject.k.length*8;return{type:"keyImport",keyData:keyObject.k,keyHandle:{algorithm:p.algorithm,extractable:p.extractable||keyObject.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoCbc.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("importKey","aes-cbc",msrcryptoCbc.importKey);operations.register("exportKey","aes-cbc",msrcryptoCbc.exportKey);operations.register("generateKey","aes-cbc",msrcryptoCbc.generateKey);operations.register("encrypt","aes-cbc",msrcryptoCbc.workerEncrypt);operations.register("decrypt","aes-cbc",msrcryptoCbc.workerDecrypt)}var msrcryptoGcm=function(blockCipher){var utils=msrcryptoUtilities;var mBuffer=[],mIvBytes,mAdditionalBytes,mTagLength,mJ0,mJ0inc,mH=blockCipher.encrypt(utils.getVector(16)),mGHashState=utils.getVector(16),mGHashBuffer=[],mCipherText=[],mGctrCb,mBytesProcessed=0;function ghash(hashSubkey,dataBytes){var blockCount=Math.floor(dataBytes.length/16),dataBlock;for(var i=0;i<blockCount;i++){dataBlock=dataBytes.slice(i*16,i*16+16);mGHashState=blockMultiplication(utils.xorVectors(mGHashState,dataBlock),hashSubkey)}mGHashBuffer=dataBytes.slice(blockCount*16);return mGHashState}function finishGHash(){var u=16*Math.ceil(mBytesProcessed/16)-mBytesProcessed;var lenA=numberTo8Bytes(mAdditionalBytes.length*8),lenC=numberTo8Bytes(mBytesProcessed*8);var p=mGHashBuffer.concat(utils.getVector(u)).concat(lenA).concat(lenC);return ghash(mH,p)}function blockMultiplication(blockX,blockY){var z=utils.getVector(16),v=blockY.slice(),r=[225,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],bit;for(var i=0;i<128;i++){bit=getBit(blockX,i);if(bit===1){z=utils.xorVectors(z,v)}if(v[15]&1){shiftRight(v);v=utils.xorVectors(v,r)}else{shiftRight(v)}}return z}function shiftRight(dataBytes){for(var i=dataBytes.length-1;i>0;i--){dataBytes[i]=(dataBytes[i-1]&1)<<7|dataBytes[i]>>>1}dataBytes[0]=dataBytes[0]>>>1;return dataBytes}function getBit(byteArray,bitNumber){var byteIndex=Math.floor(bitNumber/8);return byteArray[byteIndex]>>7-bitNumber%8&1}function inc(dataBytes){var carry=256;for(var i=1;i<=4;i++){carry=(carry>>>8)+dataBytes[dataBytes.length-i];dataBytes[dataBytes.length-i]=carry&255}return dataBytes}function gctr(icb,dataBytes){var blockCount=Math.ceil(dataBytes.length/16),dataBlock,result=[];if(mGctrCb!==icb){mGctrCb=icb.slice()}for(var block=0;block<blockCount;block++){dataBlock=dataBytes.slice(block*16,block*16+16);var e=blockCipher.encrypt(mGctrCb.slice());
result=result.concat(utils.xorVectors(dataBlock,e));mGctrCb=inc(mGctrCb)}return result}function numberTo8Bytes(number){return[0,0,0,0,number>>>24&255,number>>>16&255,number>>>8&255,number&255]}function padBlocks(dataBytes){var padLen=16*Math.ceil(mAdditionalBytes.length/16)-mAdditionalBytes.length;return dataBytes.concat(utils.getVector(padLen))}function clearState(){mBytesProcessed=0;mBuffer=[];mCipherText=[];mGHashState=utils.getVector(16);mGHashBuffer=[];mGctrCb=mIvBytes=mAdditionalBytes=null}function init(ivBytes,additionalBytes,tagLength){mAdditionalBytes=additionalBytes||[];mTagLength=isNaN(tagLength)?128:tagLength;if(mTagLength%8!==0){throw new Error("DataError")}mIvBytes=ivBytes;if(mIvBytes.length===12){mJ0=mIvBytes.concat([0,0,0,1])}else{var l=16*Math.ceil(mIvBytes.length/16)-mIvBytes.length;mJ0=ghash(mH,mIvBytes.concat(utils.getVector(l+8)).concat(numberTo8Bytes(mIvBytes.length*8)));mGHashState=utils.getVector(16)}mJ0inc=inc(mJ0.slice());ghash(mH,padBlocks(mAdditionalBytes))}function encrypt(plainBytes){mBytesProcessed=plainBytes.length;var c=gctr(mJ0inc,plainBytes);ghash(mH,c);var s=finishGHash();var t=gctr(mJ0,s).slice(0,mTagLength/8);clearState();return c.slice().concat(t)}function decrypt(cipherBytes,tagBytes){mBytesProcessed=cipherBytes.length;var p=gctr(mJ0inc,cipherBytes);ghash(mH,cipherBytes);var s=finishGHash();var t=gctr(mJ0,s).slice(0,mTagLength/8);clearState();if(utils.arraysEqual(t,tagBytes)){return p}else{return null}}function processEncrypt(plainBytes){mBuffer=mBuffer.concat(plainBytes);var fullBlocks=mBuffer.slice(0,Math.floor(mBuffer.length/16)*16);mBytesProcessed+=fullBlocks.length;mBuffer=mBuffer.slice(fullBlocks.length);var c=gctr(mGctrCb||mJ0inc,fullBlocks);mCipherText=mCipherText.concat(c);ghash(mH,c)}function processDecrypt(cipherBytes){mBuffer=mBuffer.concat(cipherBytes);var fullBlocks=mBuffer.slice(0,Math.floor((mBuffer.length-mTagLength/8)/16)*16);mBytesProcessed+=fullBlocks.length;mBuffer=mBuffer.slice(fullBlocks.length);var c=gctr(mGctrCb||mJ0inc,fullBlocks);mCipherText=mCipherText.concat(c);ghash(mH,fullBlocks)}function finishEncrypt(){var c=gctr(mGctrCb,mBuffer);mCipherText=mCipherText.concat(c);mBytesProcessed+=mBuffer.length;var s=finishGHash();var t=gctr(mJ0,s).slice(0,mTagLength/8);var result=mCipherText.slice().concat(t);clearState();return result}function finishDecrypt(){var tagLength=Math.floor(mTagLength/8);var tagBytes=mBuffer.slice(-tagLength);mBuffer=mBuffer.slice(0,mBuffer.length-tagLength);var c=gctr(mGctrCb,mBuffer);mCipherText=mCipherText.concat(c);mBytesProcessed+=mBuffer.length;var s=finishGHash();var t=gctr(mJ0,s).slice(0,mTagLength/8);var result=mCipherText.slice();clearState();if(utils.arraysEqual(t,tagBytes)){return result}else{throw new Error("OperationError")}}return{init:init,encrypt:encrypt,decrypt:decrypt,processEncrypt:processEncrypt,processDecrypt:processDecrypt,finishEncrypt:finishEncrypt,finishDecrypt:finishDecrypt}};var gcm;if(typeof operations!=="undefined"){msrcryptoGcm.encrypt=function(p){var result;if(!gcm){gcm=msrcryptoGcm(msrcryptoBlockCipher.aes(p.keyData));gcm.init(p.algorithm.iv,p.algorithm.additionalData,p.algorithm.tagLength)}if(p.operationSubType==="process"){gcm.processEncrypt(p.buffer);return}if(p.operationSubType==="finish"){result=gcm.finishEncrypt();gcm=null;return result}result=gcm.encrypt(p.buffer);gcm=null;return result};msrcryptoGcm.decrypt=function(p){var result;if(!gcm){gcm=msrcryptoGcm(msrcryptoBlockCipher.aes(p.keyData));gcm.init(p.algorithm.iv,p.algorithm.additionalData,p.algorithm.tagLength)}if(p.operationSubType==="process"){gcm.processDecrypt(p.buffer);return}if(p.operationSubType==="finish"){result=gcm.finishDecrypt();gcm=null;return result}var tagLength=Math.floor(p.algorithm.tagLength/8);var cipherBytes=p.buffer.slice(0,p.buffer.length-tagLength);var tagBytes=p.buffer.slice(-tagLength);result=gcm.decrypt(cipherBytes,tagBytes);gcm=null;return result};msrcryptoGcm.generateKey=function(p){if(p.algorithm.length%8!==0){throw new Error}return{type:"keyGeneration",keyData:msrcryptoPseudoRandom.getBytes(Math.floor(p.algorithm.length/8)),keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoGcm.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["k"]);return{type:"keyImport",keyData:keyObject.k,keyHandle:{algorithm:p.algorithm,extractable:p.extractable||keyObject.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoGcm.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("importKey","aes-gcm",msrcryptoGcm.importKey);operations.register("exportKey","aes-gcm",msrcryptoGcm.exportKey);operations.register("generateKey","aes-gcm",msrcryptoGcm.generateKey);operations.register("encrypt","aes-gcm",msrcryptoGcm.encrypt);operations.register("decrypt","aes-gcm",msrcryptoGcm.decrypt)}function MsrcryptoPrng(){if(!(this instanceof MsrcryptoPrng)){throw new Error("create MsrcryptoPrng object with new keyword")}var initialized=false;var key;var v;var keyLen;var seedLen;var reseedCounter=1;var reseedInterval=1<<24;initialize();function addOne(counter){var i;for(i=counter.length-1;i>=0;i-=1){counter[i]+=1;if(counter[i]>=256){counter[i]=0}if(counter[i]){break}}}function initialize(){key=msrcryptoUtilities.getVector(32);v=msrcryptoUtilities.getVector(16);keyLen=32;seedLen=48;reseedCounter=1}function reseed(entropy,additionalEntropy){additionalEntropy=additionalEntropy||[0];if(additionalEntropy.length>seedLen){throw new Error("Incorrect entropy or additionalEntropy length")}additionalEntropy=additionalEntropy.concat(msrcryptoUtilities.getVector(seedLen-additionalEntropy.length));entropy=entropy.concat(msrcryptoUtilities.getVector((seedLen-entropy.length%seedLen)%seedLen));for(var i=0;i<entropy.length;i+=seedLen){var seedMaterial=msrcryptoUtilities.xorVectors(entropy.slice(i,i+seedLen),additionalEntropy);update(seedMaterial)}reseedCounter=1}function update(providedData){var temp=[];var blockCipher=new msrcryptoBlockCipher.aes(key);while(temp.length<seedLen){addOne(v);var toEncrypt=v.slice(0,16);var outputBlock=blockCipher.encrypt(toEncrypt);temp=temp.concat(outputBlock)}temp=msrcryptoUtilities.xorVectors(temp,providedData);key=temp.slice(0,keyLen);v=temp.slice(keyLen)}function generate(requestedBytes,additionalInput){if(requestedBytes>=65536){throw new Error("too much random requested")}if(reseedCounter>reseedInterval){throw new Error("Reseeding is required")}if(additionalInput&&additionalInput.length>0){while(additionalInput.length<seedLen){additionalInput=additionalInput.concat(msrcryptoUtilities.getVector(seedLen-additionalInput.length))}update(additionalInput)}else{additionalInput=msrcryptoUtilities.getVector(seedLen)}var temp=[];var blockCipher=new msrcryptoBlockCipher.aes(key);while(temp.length<requestedBytes){addOne(v);var toEncrypt=v.slice(0,v.length);var outputBlock=blockCipher.encrypt(toEncrypt);temp=temp.concat(outputBlock)}temp=temp.slice(0,requestedBytes);update(additionalInput);reseedCounter+=1;return temp}return{reseed:reseed,init:function(entropy,personalization){if(entropy.length<seedLen){throw new Error("Initial entropy length too short")}initialize();reseed(entropy,personalization);initialized=true},getBytes:function(length,additionalInput){if(!initialized){throw new Error("can't get randomness before initialization")}return generate(length,additionalInput)},getNonZeroBytes:function(length,additionalInput){if(!initialized){throw new Error("can't get randomness before initialization")}var result=[],buff;while(result.length<length){buff=generate(length,additionalInput);for(var i=0;i<buff.length;i+=1){if(buff[i]!==0){result.push(buff[i])}}}return result.slice(0,length)}}}var msrcryptoPseudoRandom=new MsrcryptoPrng;function MsrcryptoEntropy(){var poolLength=48;var collectorPool=[];var collectorPoolLength=128;var collectorsRegistered=0;var entropyPoolPrng=new MsrcryptoPrng;var initialized=false;var cryptographicPRNGPresent=false;var headerList=["Cookie","RedirectUri","ETag","x-ms-client-antiforgery-id","x-ms-client-request-id","x-ms-client-session-id","SubscriptionPool"];function collectEntropy(){var i,pool=[];for(i=0;i<poolLength;i+=1){pool[i]=Math.floor(Math.random()*256)}var prngCrypto=window.crypto||window.msCrypto;if(prngCrypto&&typeof prngCrypto.getRandomValues==="function"){if(window.Uint8Array){var res=new window.Uint8Array(poolLength);prngCrypto.getRandomValues(res);pool=pool.concat(Array.apply(null,res));cryptographicPRNGPresent=true}}try{var req=new XMLHttpRequest;for(i=0;i<headerList.length;i+=1){try{var header=req.getResponseHeader(headerList[i]);if(header){var arr=msrcryptoUtilities.stringToBytes(header);pool=pool.concat(arr)}}catch(err){}}}catch(err){}if(!cryptographicPRNGPresent){pool=pool.concat(collectorPool.splice(0,collectorPool.length));collectors.startCollectors()}initialized?entropyPoolPrng.reseed(pool):entropyPoolPrng.init(pool);initialized=true}function updatePool(entropyData){for(var i=0;i<entropyData.length;++i){collectorPool.push(entropyData[i])}if(collectorPool.length>=collectorPoolLength){collectors.stopCollectors()}}var collectors=function(){return{startCollectors:function(){if(!this.collectorsRegistered){if(window.addEventListener){window.addEventListener("mousemove",this.MouseEventCallBack,true);window.addEventListener("load",this.LoadTimeCallBack,true)}else if(typeof document!=="undefined"&&document.attachEvent){document.attachEvent("onmousemove",this.MouseEventCallBack);document.attachEvent("onload",this.LoadTimeCallBack)}else{if(!nodeJsSupport)throw new Error("Can't attach events for entropy collection")}this.collectorsRegistered=1}},stopCollectors:function(){if(this.collectorsRegistered){if(window.removeEventListener){window.removeEventListener("mousemove",this.MouseEventCallBack,1);window.removeEventListener("load",this.LoadTimeCallBack,1)}else if(window.detachEvent){window.detachEvent("onmousemove",this.MouseEventCallBack);window.detachEvent("onload",this.LoadTimeCallBack)}this.collectorsRegistered=0}},MouseEventCallBack:function(eventData){var d=(new Date).valueOf();var x=eventData.x||eventData.clientX||eventData.offsetX||0;var y=eventData.y||eventData.clientY||eventData.offsetY||0;var arr=[d&255,d>>8&255,d>>16&255,d>>24&255,x&255,x>>8&255,y&255,y>>8&255];updatePool(arr)},LoadTimeCallBack:function(){var d=(new Date).valueOf();var dateArray=[d&255,d>>8&255,d>>16&255,d>>24&255];updatePool(dateArray)}}}();return{init:function(){collectEntropy();if(!cryptographicPRNGPresent&&!collectorsRegistered){try{collectors.startCollectors()}catch(e){}}},reseed:function(entropy){entropyPoolPrng.reseed(entropy)},read:function(length){if(!initialized){throw new Error("Entropy pool is not initialized.")}var ret=entropyPoolPrng.getBytes(length);collectEntropy();return ret}}}var msrcryptoRsaBase=function(keyStruct){var utils=msrcryptoUtilities,keyIsPrivate=keyStruct.hasOwnProperty("n")&&keyStruct.hasOwnProperty("d"),keyIsCrt=keyStruct.hasOwnProperty("p")&&keyStruct.hasOwnProperty("q"),modulusLength=keyStruct.n.length;function toBytes(digits){var bytes=cryptoMath.digitsToBytes(digits);utils.padFront(bytes,0,modulusLength);return bytes}function modExp(dataBytes,expBytes,modulusBytes){var exponent=cryptoMath.bytesToDigits(expBytes);var group=cryptoMath.IntegerGroup(modulusBytes);var base=group.createElementFromBytes(dataBytes);var result=group.modexp(base,exponent);return result.m_digits}function decryptModExp(cipherBytes){var resultElement=modExp(cipherBytes,keyStruct.d,keyStruct.n);return toBytes(resultElement)}function decryptCrt(cipherBytes){var p=keyStruct.p,q=keyStruct.q,dp=keyStruct.dp,dq=keyStruct.dq,invQ=keyStruct.qi,pDigits=cryptoMath.bytesToDigits(p),qDigits=cryptoMath.bytesToDigits(q),temp=new Array(pDigits.length+qDigits.length),m1Digits=new Array(pDigits.length+1),m2Digits=new Array(qDigits.length+1),cDigits=cryptoMath.bytesToDigits(cipherBytes);cryptoMath.reduce(cDigits,pDigits,temp);cryptoMath.modExp(temp,cryptoMath.bytesToDigits(dp),pDigits,m1Digits);cryptoMath.reduce(cDigits,qDigits,temp);cryptoMath.modExp(temp,cryptoMath.bytesToDigits(dq),qDigits,m2Digits);var carry=cryptoMath.subtract(m1Digits,m2Digits,temp);if(carry!==0){cryptoMath.subtract(m2Digits,m1Digits,temp)}cryptoMath.modMul(temp,cryptoMath.bytesToDigits(invQ),pDigits,cDigits);if(carry!==0){cryptoMath.subtract(pDigits,cDigits,cDigits)}cryptoMath.multiply(cDigits,qDigits,temp);cryptoMath.add(m2Digits,temp,m1Digits);return toBytes(m1Digits)}return{encrypt:function(messageBytes){return toBytes(modExp(messageBytes,keyStruct.e,keyStruct.n))},decrypt:function(cipherBytes){if(keyIsCrt){return decryptCrt(cipherBytes)}if(keyIsPrivate){return decryptModExp(cipherBytes)}throw new Error("missing private key")}}};var rsaShared={mgf1:function(seedBytes,maskLen,hashFunction){var t=[],bytes,hash,counter,hashByteLen=hashFunction.hashLen/8;for(counter=0;counter<=Math.floor(maskLen/hashByteLen);counter+=1){bytes=[counter>>>24&255,counter>>>16&255,counter>>>8&255,counter&255];hash=hashFunction.computeHash(seedBytes.concat(bytes));t=t.concat(hash)}return t.slice(0,maskLen)},checkMessageVsMaxHash:function(messageBytes,hashFunction){if(messageBytes.length>(hashFunction.maxMessageSize||4294967295)){throw new Error("message too long")}return}};var rsaMode=rsaMode||{};rsaMode.oaep=function(keyStruct,hashFunction){var utils=msrcryptoUtilities,random=msrcryptoPseudoRandom,size=keyStruct.n.length;if(hashFunction===null){throw new Error("must supply hashFunction")}function pad(message,label){var lHash,psLen,psArray,i,db,seed;var dbMask,maskeddb,seedMask,maskedSeed;var encodedMessage;if(message.length>size-2*(hashFunction.hashLen/8)-2){throw new Error("Message too long.")}label||(label=[]);lHash=hashFunction.computeHash(label);psLen=size-message.length-2*lHash.length-2;psArray=utils.getVector(psLen);db=lHash.concat(psArray,[1],message);seed=random.getBytes(lHash.length);dbMask=rsaShared.mgf1(seed,size-lHash.length-1,hashFunction);maskeddb=utils.xorVectors(db,dbMask);seedMask=rsaShared.mgf1(maskeddb,lHash.length,hashFunction);maskedSeed=utils.xorVectors(seed,seedMask);encodedMessage=[0].concat(maskedSeed).concat(maskeddb);message=encodedMessage.slice();return encodedMessage}function unpad(encodedBytes,labelBytes){var lHash,maskedSeed,maskeddb,seedMask;var seed,dbMask,db;var lHashp;if(!labelBytes){labelBytes=[]}lHash=hashFunction.computeHash(labelBytes);if(encodedBytes[0]!==0){throw new Error("Encryption Error")}maskedSeed=encodedBytes.slice(1,lHash.length+1);maskeddb=encodedBytes.slice(lHash.length+1);seedMask=rsaShared.mgf1(maskeddb,lHash.length,hashFunction);seed=utils.xorVectors(maskedSeed,seedMask);dbMask=rsaShared.mgf1(seed,size-lHash.length-1,hashFunction);db=utils.xorVectors(maskeddb,dbMask);lHashp=db.slice(0,lHash.length);if(!utils.arraysEqual(lHash,lHashp)){throw new Error("Encryption Error")}db=db.slice(lHash.length);var i=db.indexOf(1);return db.slice(i+1)}return{pad:function(messageBytes,labelBytes){return pad(messageBytes,labelBytes)},unpad:function(encodedBytes,labelBytes){return unpad(encodedBytes,labelBytes)}}};var rsaMode=rsaMode||{};rsaMode.pkcs1Encrypt=function(keyStruct){var random=msrcryptoPseudoRandom,size=keyStruct.n.length;function pad(data){var randomness;if(data.length>size-11){throw new Error("message too long")}randomness=random.getNonZeroBytes(size-data.length-3);return[0,2].concat(randomness,[0],data)}function unpad(paddedData){var i;for(i=1;i<paddedData.length;i+=1){if(paddedData[i]===0){break}}return paddedData.slice(i+1)}return{pad:function(messageBytes){return pad(messageBytes)},unpad:function(encodedBytes){return unpad(encodedBytes)}}};rsaMode.pkcs1Sign=function(keyStruct,hashFunction){var utils=msrcryptoUtilities,size=keyStruct.n.length;function emsa_pkcs1_v15_encode(messageBytes){var paddedData,hash,tlen;hash=hashFunction.computeHash(messageBytes.slice());paddedData=hashFunction.der.concat(hash);tlen=paddedData.length;if(size<tlen+11){throw new Error("intended encoded message length too short")}return[0,1].concat(utils.getVector(size-tlen-3,255),[0],paddedData)}return{sign:function(messageBytes){return emsa_pkcs1_v15_encode(messageBytes)},verify:function(signatureBytes,messageBytes){var emp=emsa_pkcs1_v15_encode(messageBytes);return utils.arraysEqual(signatureBytes,emp)}}};var rsaMode=rsaMode||{};rsaMode.pss=function(keyStruct,hashFunction){var utils=msrcryptoUtilities,random=msrcryptoPseudoRandom;function emsa_pss_encode(messageBytes,saltLength,salt){var emBits=keyStruct.n.length*8-1,emLen=Math.ceil(emBits/8),mHash=hashFunction.computeHash(messageBytes);saltLength=salt?salt.length:saltLength||mHash.length;if(emLen<mHash.length+saltLength+2){throw new Error("encoding error")}salt=salt||random.getBytes(saltLength);var mp=[0,0,0,0,0,0,0,0].concat(mHash,salt);var h=hashFunction.computeHash(mp);var ps=utils.getVector(emLen-salt.length-h.length-2);var db=ps.concat([1],salt);var dbMask=rsaShared.mgf1(h,emLen-h.length-1,hashFunction);var maskedDb=utils.xorVectors(db,dbMask);var mask=0;for(var i=0;i<8-(8*emLen-emBits);i++){mask+=1<<i}maskedDb[0]&=mask;var em=maskedDb.concat(h,[188]);return em}function emsa_pss_verify(signatureBytes,messageBytes,saltLength){var emBits=keyStruct.n.length*8-1;var emLen=Math.ceil(emBits/8);var mHash=hashFunction.computeHash(messageBytes);var hLen=mHash.length;saltLength=saltLength||hLen;if(emLen<hLen+saltLength+2){return false}var maskedDb=signatureBytes.slice(0,emLen-hLen-1);var h=signatureBytes.slice(maskedDb.length,maskedDb.length+hLen);var dbMask=rsaShared.mgf1(h,emLen-hLen-1,hashFunction);var db=utils.xorVectors(maskedDb,dbMask);db[0]&=255>>>8-(8*emLen-emBits);for(var i=0;i<emLen-hLen-saltLength-2;i++){if(db[i]!==0){return false}}if(db[emLen-hLen-saltLength-2]!==1){return false}var salt=db.slice(-saltLength);var mp=[0,0,0,0,0,0,0,0].concat(mHash,salt);var hp=hashFunction.computeHash(mp);return utils.arraysEqual(hp,h)}return{sign:function(messageBytes,saltLength,salt){return emsa_pss_encode(messageBytes,saltLength,salt)},verify:function(signatureBytes,messageBytes,saltLength){return emsa_pss_verify(signatureBytes,messageBytes,saltLength)}}};var msrcryptoRsa=function(keyStruct,mode,hashFunction){var rsaBase=msrcryptoRsaBase(keyStruct);if(!mode){throw new Error("padding mode")}function checkHash(){if(!hashFunction||!hashFunction.computeHash){throw new Error("missing hash function")}}var paddingFunction=null,unPaddingFunction=null;var padding;switch(mode){case"rsaes-pkcs1-v1_5":padding=rsaMode.pkcs1Encrypt(keyStruct);break;case"rsassa-pkcs1-v1_5":checkHash();padding=rsaMode.pkcs1Sign(keyStruct,hashFunction);break;case"rsa-oaep":checkHash();padding=rsaMode.oaep(keyStruct,hashFunction);break;case"rsa-pss":checkHash();padding=rsaMode.pss(keyStruct,hashFunction);break;case"raw":padding={pad:function(mb){return mb},unpad:function(eb){return eb}};break;default:throw new Error("invalid mode")}if(padding){paddingFunction=padding.pad||padding.sign;unPaddingFunction=padding.unpad||padding.verify}var returnObj={encrypt:function(dataBytes,labelBytes){var paddedData;if(paddingFunction!==null){paddedData=paddingFunction(dataBytes,labelBytes)}else{paddedData=dataBytes.slice()}return rsaBase.encrypt(paddedData)},decrypt:function(cipherBytes,labelBytes){var decryptedData=rsaBase.decrypt(cipherBytes);if(unPaddingFunction!==null){decryptedData=unPaddingFunction(decryptedData,labelBytes)}else{decryptedData=decryptedData.slice(0)}return decryptedData},signData:function(messageBytes,saltLength,salt){return rsaBase.decrypt(paddingFunction(messageBytes,saltLength,salt))},verifySignature:function(signature,messageBytes,saltLength){var decryptedSig=rsaBase.encrypt(signature);return unPaddingFunction(decryptedSig,messageBytes,saltLength)},mode:mode};return returnObj};if(typeof operations!=="undefined"){msrcryptoRsa.sign=function(p){var rsaObj,hashName=p.algorithm.hash.name,hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()],saltLength=p.algorithm.saltLength,salt=p.algorithm.salt;rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name,hashFunc);return rsaObj.signData(p.buffer,saltLength,salt)};msrcryptoRsa.verify=function(p){var hashName=p.algorithm.hash.name,hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()],rsaObj,saltLength=p.algorithm.saltLength;rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name,hashFunc);return rsaObj.verifySignature(p.signature,p.buffer,saltLength)};msrcryptoRsa.workerEncrypt=function(p){var result,rsaObj,hashFunc,hashName;switch(p.algorithm.name){case"rsaes-pkcs1-v1_5":rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name);result=rsaObj.encrypt(p.buffer);break;case"rsa-oaep":hashName=p.algorithm.hash.name;if(!hashName){throw new Error("unsupported hash algorithm")}hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()];rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name,hashFunc);result=rsaObj.encrypt(p.buffer);break;default:throw new Error("unsupported algorithm")}return result};msrcryptoRsa.workerDecrypt=function(p){var result,rsaObj,hashFunc;switch(p.algorithm.name){case"rsaes-pkcs1-v1_5":rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name);result=rsaObj.decrypt(p.buffer);break;case"rsa-oaep":var hashName=p.algorithm.hash.name;if(!hashName){throw new Error("unsupported hash algorithm")}hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()];rsaObj=msrcryptoRsa(p.keyData,p.algorithm.name,hashFunc);result=rsaObj.decrypt(p.buffer);break;default:throw new Error("unsupported algorithm")}return result};msrcryptoRsa.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["n","e","d","q","p","dq","dp","qi"]);return{type:"keyImport",keyData:keyObject,keyHandle:{algorithm:p.algorithm,extractable:p.extractable||keyObject.extractable,keyUsage:null||p.keyUsage,type:keyObject.d||keyObject.dq?"private":"public"}}};msrcryptoRsa.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("sign","rsassa-pkcs1-v1_5",msrcryptoRsa.sign);operations.register("sign","rsa-pss",msrcryptoRsa.sign);operations.register("verify","rsassa-pkcs1-v1_5",msrcryptoRsa.verify);operations.register("verify","rsa-pss",msrcryptoRsa.verify);operations.register("encrypt","rsa-oaep",msrcryptoRsa.workerEncrypt);operations.register("encrypt","rsaes-pkcs1-v1_5",msrcryptoRsa.workerEncrypt);operations.register("decrypt","rsa-oaep",msrcryptoRsa.workerDecrypt);operations.register("decrypt","rsaes-pkcs1-v1_5",msrcryptoRsa.workerDecrypt);operations.register("importKey","rsa-oaep",msrcryptoRsa.importKey);operations.register("importKey","rsaes-pkcs1-v1_5",msrcryptoRsa.importKey);operations.register("importKey","rsassa-pkcs1-v1_5",msrcryptoRsa.importKey);operations.register("importKey","rsa-pss",msrcryptoRsa.importKey);operations.register("exportKey","rsa-oaep",msrcryptoRsa.exportKey);operations.register("exportKey","rsaes-pkcs1-v1_5",msrcryptoRsa.exportKey);operations.register("exportKey","rsassa-pkcs1-v1_5",msrcryptoRsa.exportKey);operations.register("exportKey","rsa-pss",msrcryptoRsa.exportKey)}var msrcryptoKdf=function(hashFunction){var utils=msrcryptoUtilities;function deriveKey(secretBytes,otherInfo,keyOutputLength){var reps=Math.ceil(keyOutputLength/(hashFunction.hashLen/8)),counter=1,digest=secretBytes.concat(otherInfo),output=[];for(var i=0;i<reps;i++){var data=utils.int32ToBytes(counter++).concat(digest);var h=hashFunction.computeHash(data);output=output.concat(h)}return output.slice(0,keyOutputLength)}return{deriveKey:deriveKey}};var msrcryptoKdfInstance=null;if(typeof operations!=="undefined"){msrcryptoKdf.deriveKey=function(p){var utils=msrcryptoUtilities;var hashName=p.algorithm.hash.name;var hashFunction=msrcryptoHashFunctions[hashName.toLowerCase()];msrcryptoKdfInstance=msrcryptoKdf(hashFunction);var alg=p.algorithm;var otherInfo=utils.toArray(alg.algorithmId).concat(utils.toArray(alg.partyUInfo),utils.toArray(alg.partyVInfo),utils.toArray(alg.publicInfo),utils.toArray(alg.privateInfo));var result=msrcryptoKdfInstance.deriveKey(p.keyData,otherInfo,p.derivedKeyType.length);msrcryptoKdfInstance=null;return{type:"keyDerive",keyData:result,keyHandle:{algorithm:p.derivedKeyType,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"secret"}}};msrcryptoKdf.deriveBits=function(p){var hashName=p.algorithm.hash.name;var hashFunction=msrcryptoHashFunctions[hashName.toLowerCase()];msrcryptoKdfInstance=msrcryptoKdf(hashFunction);var alg=p.algorithm;var otherInfo=alg.algorithmId.concat(alg.partyUInfo,alg.partyVInfo,alg.publicInfo||[],alg.privateInfo||[]);var result=msrcryptoKdfInstance.deriveKey(p.keyData,otherInfo,p.length);msrcryptoKdfInstance=null;return result};operations.register("deriveKey","concat",msrcryptoKdf.deriveKey);operations.register("deriveBits","concat",msrcryptoKdf.deriveBits)}var msrcryptoEcdh=function(curve){var btd=cryptoMath.bytesToDigits,dtb=cryptoMath.digitsToBytes,e=curve,ecop=new cryptoECC.EllipticCurveOperatorFp(curve);function generateKey(privateKeyBytes){var privateKey=[],randomBytes=msrcryptoPseudoRandom.getBytes(curve.order.length*cryptoMath.DIGIT_NUM_BYTES);randomBytes=privateKeyBytes||randomBytes;cryptoMath.reduce(cryptoMath.bytesToDigits(randomBytes),e.order,privateKey);var publicKey=e.allocatePointStorage();ecop.scalarMultiply(privateKey,e.generator,publicKey);return{privateKey:{x:dtb(publicKey.x),y:dtb(publicKey.y),d:dtb(privateKey)},publicKey:{x:dtb(publicKey.x),y:dtb(publicKey.y)}}}function deriveBits(privateKey,publicKey,length){var publicPoint=new cryptoECC.EllipticCurvePointFp(e,false,btd(publicKey.x),btd(publicKey.y),null,false);if(!publicPoint.isInMontgomeryForm){ecop.convertToMontgomeryForm(publicPoint)}if(!publicPoint.isAffine){ecop.convertToAffineForm(publicPoint)}var sharedSecretPoint=e.allocatePointStorage();ecop.convertToJacobianForm(sharedSecretPoint);ecop.convertToMontgomeryForm(sharedSecretPoint);ecop.scalarMultiply(btd(privateKey.d),publicPoint,sharedSecretPoint);ecop.convertToAffineForm(sharedSecretPoint);ecop.convertToStandardForm(sharedSecretPoint);var secretBytes=cryptoMath.digitsToBytes(sharedSecretPoint.x);if(length&&secretBytes.length*8<length){throw new Error("DataError")}return length?secretBytes.slice(0,length/8):secretBytes}function computePublicKey(privateKeyBytes){if(!e.generator.isInMontgomeryForm){ecop.convertToMontgomeryForm(e.generator)}var publicKey=e.allocatePointStorage();ecop.convertToJacobianForm(publicKey);ecop.convertToMontgomeryForm(publicKey);ecop.scalarMultiply(btd(privateKeyBytes),e.generator,publicKey);return{x:dtb(publicKey.x),y:dtb(publicKey.y)}}return{generateKey:generateKey,deriveBits:deriveBits,computePublicKey:computePublicKey}};var ecdhInstance=null;if(typeof operations!=="undefined"){msrcryptoEcdh.deriveBits=function(p){var curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase());var privateKey=p.keyData;var publicKey=p.additionalKeyData;ecdhInstance=msrcryptoEcdh(curve);var secretBytes=ecdhInstance.deriveBits(privateKey,publicKey,p.length);return secretBytes};msrcryptoEcdh.generateKey=function(p){var curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase());ecdhInstance=msrcryptoEcdh(curve);var keyPairData=ecdhInstance.generateKey();return{type:"keyPairGeneration",keyPair:{publicKey:{keyData:keyPairData.publicKey,keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:p.keyUsage,type:"public"}},privateKey:{keyData:keyPairData.privateKey,keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:p.keyUsage,type:"private"}}}}};msrcryptoEcdh.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["x","y","d","crv"]);if(keyObject.d&&(!keyObject.x||!keyObject.y)){var curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase());ecdhInstance=msrcryptoEcdh(curve);var publicKey=ecdhInstance.computePublicKey(keyObject.d);keyObject.x=publicKey.x;keyObject.y=publicKey.y}return{type:"keyImport",keyData:keyObject,keyHandle:{algorithm:p.algorithm,extractable:p.extractable||keyObject.extractable,keyUsage:p.keyUsage,type:keyObject.d?"private":"public"}}};msrcryptoEcdh.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("importKey","ecdh",msrcryptoEcdh.importKey);operations.register("exportKey","ecdh",msrcryptoEcdh.exportKey);operations.register("generateKey","ecdh",msrcryptoEcdh.generateKey);operations.register("deriveBits","ecdh",msrcryptoEcdh.deriveBits)}var msrcryptoEcdsa=function(curve){var btd=cryptoMath.bytesToDigits,dtb=cryptoMath.digitsToBytes,ecop=new cryptoECC.EllipticCurveOperatorFp(curve),orderByteLength=dtb(curve.order).length,tedCurve=curve.type===1;function createKey(privateKeyBytes){return createKeyInternal(btd(privateKeyBytes))}function createKeyInternal(privateKeyDigits){var publicKey=curve.allocatePointStorage();ecop.scalarMultiply(privateKeyDigits,curve.generator,publicKey);return{publicKey:publicKey,privateKey:privateKeyDigits}}function generateKey(randomBytes){var privateKey=[];if(!randomBytes){randomBytes=msrcryptoPseudoRandom.getBytes(curve.order.length*cryptoMath.DIGIT_NUM_BYTES)}cryptoMath.reduce(cryptoMath.bytesToDigits(randomBytes),curve.order,privateKey);return createKeyInternal(privateKey)}function getDigest(messageBytes){if(messageBytes.length>orderByteLength){messageBytes.length=orderByteLength}var digest=btd(messageBytes);if(tedCurve){var shift=8-curve.rbits%8;cryptoMath.shiftRight(digest,digest,shift)}cryptoMath.reduce(digest,curve.order,digest);return digest}function sign(privateKey,messageBytes,ephemeralKey){if(!ephemeralKey){ephemeralKey=generateKey()}var r=ephemeralKey.publicKey.x,k=ephemeralKey.privateKey,d=btd(privateKey.d),digest=getDigest(messageBytes.slice()),s=[],tmp=[],signature=null;cryptoMath.reduce(r,curve.order,r);cryptoMath.modMul(r,d,curve.order,s);cryptoMath.add(s,digest,s);cryptoMath.reduce(s,curve.order,s);cryptoMath.modInv(k,curve.order,tmp);cryptoMath.modMul(s,tmp,curve.order,s);signature=dtb(r,true,orderByteLength).concat(dtb(s,true,orderByteLength));return signature}function verify(publicKey,signatureBytes,messageBytes){var split=Math.floor(signatureBytes.length/2),r=btd(signatureBytes.slice(0,split)),s=btd(signatureBytes.slice(split)),digest=getDigest(messageBytes.slice()),u1=[],u2=[];var publicPoint=new cryptoECC.EllipticCurvePointFp(curve,false,btd(publicKey.x),btd(publicKey.y),null,false);cryptoMath.modInv(s,curve.order,s);cryptoMath.modMul(digest,s,curve.order,u1);cryptoMath.modMul(r,s,curve.order,u2);var r0=curve.allocatePointStorage();var r1=curve.allocatePointStorage();if(tedCurve){cryptoMath.add(u1,u1,u1);cryptoMath.add(u1,u1,u1);cryptoMath.reduce(u1,curve.order,u1);ecop.scalarMultiply(u1,curve.generator,r0,false);ecop.scalarMultiply(u2,publicPoint,r1,false);ecop.convertToExtendedProjective(r0);ecop.convertToExtendedProjective(r1);ecop.add(r1,r0,r0);ecop.normalize(r0)}else{ecop.scalarMultiply(u1,curve.generator,r0);ecop.scalarMultiply(u2,publicPoint,r1);ecop.convertToJacobianForm(r0);ecop.convertToMontgomeryForm(r0);ecop.convertToMontgomeryForm(r1);ecop.mixedAdd(r0,r1,r0);ecop.convertToAffineForm(r0);ecop.convertToStandardForm(r0)}if(r0.isInfinity){return false}cryptoMath.reduce(r0.x,curve.order,r0.x);return cryptoMath.compareDigits(r0.x,r)===0}return{createKey:createKey,generateKey:generateKey,sign:sign,verify:verify}};if(typeof operations!=="undefined"){msrcryptoEcdsa.sign=function(p){var hashName=p.algorithm.hash.name,curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase()),hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()],digest=hashFunc.computeHash(p.buffer);var ecdsa=msrcryptoEcdsa(curve);return ecdsa.sign(p.keyData,digest)};msrcryptoEcdsa.verify=function(p){var hashName=p.algorithm.hash.name,curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase()),hashFunc=msrcryptoHashFunctions[hashName.toLowerCase()],digest=hashFunc.computeHash(p.buffer);var ecdsa=msrcryptoEcdsa(curve);
return ecdsa.verify(p.keyData,p.signature,digest)};msrcryptoEcdsa.generateKey=function(p){var curve=cryptoECC.createCurve(p.algorithm.namedCurve.toUpperCase());var ecdsa=msrcryptoEcdsa(curve);var keyPairData=ecdsa.generateKey();var dtb=cryptoMath.digitsToBytes;function padTo8BytesIncrement(array){return msrcryptoUtilities.padFront(array,0,Math.ceil(array.length/8)*8)}var x=padTo8BytesIncrement(dtb(keyPairData.publicKey.x));var y=padTo8BytesIncrement(dtb(keyPairData.publicKey.y));var d=padTo8BytesIncrement(dtb(keyPairData.privateKey));return{type:"keyPairGeneration",keyPair:{publicKey:{keyData:{x:x,y:y},keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"public"}},privateKey:{keyData:{x:x,y:y,d:d},keyHandle:{algorithm:p.algorithm,extractable:p.extractable,keyUsage:null||p.keyUsage,type:"private"}}}}};msrcryptoEcdsa.importKey=function(p){var keyObject=msrcryptoJwk.jwkToKey(p.keyData,p.algorithm,["x","y","d","crv"]);if(keyObject.d&&(!keyObject.x||!keyObject.y)){var curve=msrcryptoEcdsa.curves[p.algorithm.namedCurve]();var ecdsa=msrcryptoEcdsa(curve);var publicKey=ecdsa.computePublicKey(keyObject.d);keyObject.x=publicKey.x;keyObject.y=publicKey.y}return{type:"keyImport",keyData:keyObject,keyHandle:{algorithm:p.algorithm,extractable:p.extractable||keyObject.extractable,keyUsage:null||p.keyUsage,type:keyObject.d?"private":"public"}}};msrcryptoEcdsa.exportKey=function(p){var jsonKeyStringArray=msrcryptoJwk.keyToJwk(p.keyHandle,p.keyData);return{type:"keyExport",keyHandle:jsonKeyStringArray}};operations.register("sign","ecdsa",msrcryptoEcdsa.sign);operations.register("verify","ecdsa",msrcryptoEcdsa.verify);operations.register("generateKey","ecdsa",msrcryptoEcdsa.generateKey);operations.register("importKey","ecdsa",msrcryptoEcdsa.importKey);operations.register("exportKey","ecdsa",msrcryptoEcdsa.exportKey)}var msrcryptoSubtle;if(!runningInWorkerInstance){msrcryptoSubtle=function(){if(!window.Promise){window.Promise=function(executor,id){if(!(this instanceof Promise)){throw new Error("use 'new' keyword with Promise constructor")}var successResult=null,failReason=null,thenResolved=[],thenRejected=[],rejectThenPromise=[],resolveThenPromise=[];this.then=function(onCompleted,onRejected){var thenFunctionResult;if(successResult){thenFunctionResult=onCompleted(successResult.result);if(thenFunctionResult&&thenFunctionResult.then){return thenFunctionResult}return Promise.resolve(thenFunctionResult)}if(failReason){thenFunctionResult=onRejected?onRejected(failReason.result):failReason.result;if(thenFunctionResult&&thenFunctionResult.then){return thenFunctionResult}return Promise.resolve(thenFunctionResult)}thenResolved.push(onCompleted);if(onRejected){thenRejected.push(onRejected)}return new Promise(function(resolve,reject){resolveThenPromise.push(resolve);rejectThenPromise.push(reject)})};this["catch"]=function(onRejected){var catchFunctionResult;if(failReason){catchFunctionResult=onRejected(failReason.result);if(catchFunctionResult&&catchFunctionResult.then){return catchFunctionResult}return Promise.resolve(catchFunctionResult)}thenRejected.push(onRejected);return new Promise(function(resolve,reject){resolveThenPromise.push(resolve);rejectThenPromise.push(reject)})};var resolve=function(param){for(var i=0;i<thenResolved.length;i++){var result=thenResolved[i](param);if(result&&result.then){result.then(resolveThenPromise[i])}else{if(resolveThenPromise[i]){resolveThenPromise[i](result)}}}successResult={result:param};return};function reject(param){for(var i=0;i<thenRejected.length;i++){var reason=thenRejected[i](param);if(reason&&reason.then){reason.then(resolveThenPromise[i],rejectThenPromise[i])}else{if(resolveThenPromise[i]){resolveThenPromise[i](reason)}}}failReason={result:param};return}executor(resolve,reject);return};window.Promise.all=function(promiseArray){var results=[],resultCount=0;function then(index,resolve){return function(result){results[index]=result;if(++resultCount==promiseArray.length){resolve(results)}}}var promiseAll=new Promise(function(resolve,reject){for(var i=0;i<promiseArray.length;i++){promiseArray[i].then(then(i,resolve));promiseArray[i]["catch"](function(reason){reject(reason)})}});return promiseAll};window.Promise.race=function(promiseArray){var resolved=false;function then(resolveFunction){return function(result){if(!resolved){resolved=true;resolveFunction(result)}}}var promiseRace=new Promise(function(resolve,reject){for(var i=0;i<promiseArray.length;i++){promiseArray[i].then(then(resolve),then(reject))}});return promiseRace};window.Promise.reject=function(rejectReason){return new Promise(function(resolve,reject){reject(rejectReason)})};window.Promise.resolve=function(resolveResult){return new Promise(function(resolve,reject){resolve(resolveResult)})}}function syncWorker(){var result;function postMessage(data){try{if(data.operationType=="encrypt"||data.operationType=="decrypt"){data.operationSubType="process";msrcryptoWorker.jsCryptoRunner({data:data});data.operationSubType="finish"}result=msrcryptoWorker.jsCryptoRunner({data:data})}catch(ex){this.onerror({data:ex.description,type:"error"});return}if(!data.operationSubType||data.operationSubType!=="process"){this.onmessage({data:result})}}return{postMessage:postMessage,onmessage:null,onerror:null,terminate:function(){}}}function baseOperation(processResults){var result=null,oncompleteCallback=null,onerrorCallback=null,retObj,promise,resolveFunc,rejectFunc;promise=new Promise(function(resolve,reject){resolveFunc=resolve;rejectFunc=reject});function opDispatchEvent(e){if(e.type==="error"){if(rejectFunc){rejectFunc.apply(promise,[e.message?e.message:e])}return}this.result=processResults(e.data);resolveFunc.apply(promise,[this.result]);return}retObj={dispatchEvent:opDispatchEvent,promise:promise,result:null};return retObj}function keyOperation(){function processResult(result){switch(result.type){case"keyGeneration":case"keyImport":case"keyDerive":keys.add(result.keyHandle,result.keyData);return result.keyHandle;case"keyExport":return result.keyHandle;case"keyPairGeneration":keys.add(result.keyPair.publicKey.keyHandle,result.keyPair.publicKey.keyData);keys.add(result.keyPair.privateKey.keyHandle,result.keyPair.privateKey.keyData);return{publicKey:result.keyPair.publicKey.keyHandle,privateKey:result.keyPair.privateKey.keyHandle};default:throw new Error("Unknown key operation")}return}return baseOperation(processResult)}function cryptoOperation(cryptoContext){function processResult(result){result=toArrayBufferIfSupported(result);return result}var op=baseOperation(processResult);op.process=function(buffer){cryptoContext.operationSubType="process";cryptoContext.buffer=utils.toArray(buffer);workerManager.continueJob(this,utils.clone(cryptoContext))};op.finish=function(){cryptoContext.operationSubType="finish";cryptoContext.buffer=[];workerManager.continueJob(this,utils.clone(cryptoContext))};op.abort=function(){workerManager.abortJob(this)};op.onabort=null;op.onprogress=null;op.algorithm=cryptoContext.algorithm||null;op.key=cryptoContext.keyHandle||null;return op}function toArrayBufferIfSupported(dataArray){if(typedArraySupport&&dataArray.pop){return new Uint8Array(dataArray).buffer}return dataArray}var keys=[];keys.add=function(keyHandle,keyData){keys.push({keyHandle:keyHandle,keyData:keyData})};keys.remove=function(keyHandle){for(var i=0;i<keys.length;i++){if(keys[i].keyHandle===keyHandle){keys=keys.splice(i,1);return}}};keys.lookup=function(keyHandle){for(var i=0;i<keys.length;i++){if(keys[i].keyHandle===keyHandle){return keys[i].keyData}}return null};var workerManager=function(){var maxWorkers=12;var maxFreeWorkers=2;var workerPool=[];var jobQueue=[];var jobId=0;function getFreeWorker(){purgeWorkerType(!asyncMode);for(var i=0;i<workerPool.length;i++){if(!workerPool[i].busy){return workerPool[i]}}return null}function purgeWorkerType(webWorker){for(var i=workerPool.length-1;i>=0;i-=1){if(workerPool[i].isWebWorker===webWorker){workerPool[i].terminate();workerPool.splice(i,1)}}}function freeWorkerCount(){var freeWorkers=0;for(var i=0;i<workerPool.length;i++){if(!workerPool[i].busy){freeWorkers+=1}}return freeWorkers}function addWorkerToPool(worker){workerPool.push(worker)}function removeWorkerFromPool(worker){for(var i=0;i<workerPool.length;i++){if(workerPool[i]===worker){worker.terminate();workerPool.splice(i,1);return}}}function lookupWorkerByOperation(operation){for(var i=0;i<workerPool.length;i++){if(workerPool[i].operation===operation){return workerPool[i]}}return null}function queueJob(operation,data){jobQueue.push({operation:operation,data:data,id:jobId++})}function jobCompleted(worker){worker.busy=false;worker.operation=null;if(asyncMode){if(jobQueue.length>0){var job=jobQueue.shift();continueJob(job.operation,job.data)}else if(freeWorkerCount()>maxFreeWorkers){removeWorkerFromPool(worker)}}}function createNewWorker(operation){var worker;if(asyncMode){try{worker=new Worker(scriptUrl);worker.postMessage({prngSeed:msrcryptoPseudoRandom.getBytes(48)});worker.isWebWorker=true}catch(ex){asyncMode=false;publicMethods.forceSync=true;worker=syncWorker();worker.isWebWorker=false}}else{worker=syncWorker();worker.isWebWorker=false}worker.operation=operation;worker.busy=false;worker.onmessage=function(e){var op=worker.operation;for(var i=0;i<jobQueue.length;i++){if(jobQueue[i].operation===worker.operation){var job=jobQueue[i];jobQueue.splice(i,1);postMessageToWorker(worker,job.data);return}}if(op&&e.data.type!=="process"){jobCompleted(worker);op.dispatchEvent(e)}};worker.onerror=function(e){var op=worker.operation;jobCompleted(worker);op.dispatchEvent(e)};addWorkerToPool(worker);return worker}function abortJob(cryptoOperationObject){var worker=lookupWorkerByOperation(cryptoOperationObject);if(worker){removeWorkerFromPool(worker)}}function runJob(operation,data){var worker=null;asyncMode=webWorkerSupport&&!publicMethods.forceSync;worker=getFreeWorker();if(asyncMode&&worker===null&&workerPool.length>=maxWorkers){queueJob(operation,data);return}if(worker===null){worker=createNewWorker(operation)}if(worker===null){queueJob(operation,data);throw new Error("could not create new worker")}worker.operation=operation;worker.busy=true;postMessageToWorker(worker,data)}function continueJob(operation,data){var worker=lookupWorkerByOperation(operation);if(worker){postMessageToWorker(worker,data);return}runJob(operation,data)}function postMessageToWorker(worker,data){if(asyncMode){worker.data=data;worker.postMessage(data)}else{var func=function(postData){return function(){return worker.postMessage(postData)}}(data);var id=setTimeout(func,0)}return}return{runJob:runJob,continueJob:continueJob,abortJob:abortJob}}();var utils=msrcryptoUtilities;function checkOperation(operationType,algorithmName){if(!operations.exists(operationType,algorithmName)){throw new Error("unsupported algorithm")}}var subtleParameters=[{name:"algorithm",type:"Object",required:true},{name:"keyHandle",type:"Object",required:true},{name:"buffer",type:"Array",required:false},{name:"signature",type:"Array",required:true},{name:"format",type:"String",required:true},{name:"keyData",type:"Object",required:true},{name:"extractable",type:"Boolean",required:false},{name:"keyUsage",type:"Array",required:false},{name:"derivedKeyType",type:"Object",required:true},{name:"length",type:"Number",required:false},{name:"extractable",type:"Boolean",required:true},{name:"keyUsage",type:"Array",required:true}];var subtleParametersSets={encrypt:[0,1,2],decrypt:[0,1,2],sign:[0,1,2],verify:[0,1,3,2],digest:[0,2],generateKey:[0,6,7],importKey:[4,5,0,10,11],exportKey:[0,4,1,6,7],deriveKey:[0,1,8,6,7],deriveBits:[0,1,9],wrapKey:[1,1,0],unwrapKey:[2,0,1,6,7]};function lookupKeyData(handle){var data=keys.lookup(handle);if(!data){throw new Error("key not found")}return data}function buildParameterCollection(operationName,parameterSet){var parameterCollection={operationType:operationName},operationParameterSet=subtleParametersSets[operationName];for(var i=0;i<operationParameterSet.length;i+=1){var expectedParam=subtleParameters[operationParameterSet[i]];var actualParam=parameterSet[i];if(!actualParam){if(expectedParam.required){throw new Error(expectedParam.name)}else{continue}}if(actualParam.subarray){actualParam=utils.toArray(actualParam)}if(utils.getObjectType(actualParam)=="ArrayBuffer"){actualParam=utils.toArray(actualParam)}if(msrcryptoUtilities.getObjectType(actualParam)!==expectedParam.type){throw new Error(expectedParam.name)}if(expectedParam.name==="algorithm"){actualParam.name=actualParam.name.toLowerCase();if(actualParam.iv){actualParam.iv=utils.toArray(actualParam.iv)}if(actualParam.salt){actualParam.salt=utils.toArray(actualParam.salt)}if(actualParam.additionalData){actualParam.additionalData=utils.toArray(actualParam.additionalData)}if(actualParam.hash&&!actualParam.hash.name&&msrcryptoUtilities.getObjectType(actualParam.hash)==="String"){actualParam.hash={name:actualParam.hash}}}if(parameterCollection.hasOwnProperty(expectedParam.name)){parameterCollection[expectedParam.name+"1"]=actualParam}else{parameterCollection[expectedParam.name]=actualParam}}return parameterCollection}function executeOperation(operationName,parameterSet,keyFunc){var pc=buildParameterCollection(operationName,parameterSet);checkOperation(operationName,pc.algorithm.name);if(pc.keyHandle){pc.keyData=lookupKeyData(pc.keyHandle)}if(pc.keyHandle1){pc.keyData1=lookupKeyData(pc.keyHandle1)}if(pc.algorithm&&pc.algorithm.public){pc.additionalKeyData=lookupKeyData(pc.algorithm.public)}var op=keyFunc?keyOperation(pc):cryptoOperation(pc);if(keyFunc||pc.buffer||operationName==="deriveBits"||operationName==="wrapKey"){workerManager.runJob(op,pc)}return op.promise}var publicMethods={encrypt:function(algorithm,keyHandle,buffer){return executeOperation("encrypt",arguments,0)},decrypt:function(algorithm,keyHandle,buffer){return executeOperation("decrypt",arguments,0)},sign:function(algorithm,keyHandle,buffer){return executeOperation("sign",arguments,0)},verify:function(algorithm,keyHandle,signature,buffer){return executeOperation("verify",arguments,0)},digest:function(algorithm,buffer){return executeOperation("digest",arguments,0)},generateKey:function(algorithm,extractable,keyUsage){return executeOperation("generateKey",arguments,1)},deriveKey:function(algorithm,baseKey,derivedKeyType,extractable,keyUsage){return executeOperation("deriveKey",arguments,1)},deriveBits:function(algorithm,baseKey,length){return executeOperation("deriveBits",arguments,0)},importKey:function(format,keyData,algorithm,extractable,keyUsage){return executeOperation("importKey",arguments,1)},exportKey:function(format,keyHandle){return executeOperation("exportKey",[keyHandle.algorithm,format,keyHandle],1)},wrapKey:function(format,key,wrappingKey,wrappingKeyAlgorithm){return executeOperation("wrapKey",arguments,0)},unwrapKey:function(format,unwrappingKey,unwrapAlgorithm,unwrappedKeyAlgorithm,extractable,keyUsage){return executeOperation("unwrapKey",arguments,1)}};return publicMethods}()}var msrcryptoWrapKey=function(){var utils=msrcryptoUtilities;function wrapKey(params){var rsaObj=msrcryptoRsa(params.keyData1,params.keyHandle1.algorithm.name,msrcryptoHashFunctions["sha-1"]);var tagLength=128;var keyToWrapJwk=msrcryptoJwk.keyToJwkOld(params.keyHandle,params.keyData);var jweHeader={alg:params.keyHandle1.algorithm.name.toUpperCase(),enc:"A128GCM"};var encodedJweHeader=utils.toBase64(JSON.stringify(jweHeader),true);var cmk=msrcryptoPseudoRandom.getBytes(32);var jweEncryptedKey=rsaObj.encrypt(cmk);var encodedJweEncryptedKey=utils.toBase64(jweEncryptedKey,true);var jweIv=msrcryptoPseudoRandom.getBytes(12);var encodedJweIv=utils.toBase64(jweIv,true);var additionalData=encodedJweHeader.concat(".",encodedJweEncryptedKey,".",encodedJweIv);var gcm=msrcryptoGcm(msrcryptoBlockCipher.aes(cmk));gcm.init(jweIv,utils.stringToBytes(additionalData),tagLength);var ciphertextPlusTag=gcm.encrypt(keyToWrapJwk);var tag=ciphertextPlusTag.slice(-(tagLength/8));var encodedIntegrityValue=utils.toBase64(tag,true);var encodedCiphertext=utils.toBase64(ciphertextPlusTag.slice(0,ciphertextPlusTag.length-tag.length),true);var jwe={recipients:[{header:encodedJweHeader,encrypted_key:encodedJweEncryptedKey,integrity_value:encodedIntegrityValue}],initialization_vector:encodedJweIv,ciphertext:encodedCiphertext};return utils.stringToBytes(JSON.stringify(jwe))}function unwrapKey(params){var b64Tobytes=utils.base64ToBytes;var keyDataJwk=JSON.parse(String.fromCharCode.apply(null,params.buffer));var header=utils.base64ToString(keyDataJwk.recipients[0].header);var encrypted_key=b64Tobytes(keyDataJwk.recipients[0].encrypted_key);var integrity_value=b64Tobytes(keyDataJwk.recipients[0].integrity_value);var initialization_vector=b64Tobytes(keyDataJwk.initialization_vector);var ciphertext=b64Tobytes(keyDataJwk.ciphertext);var hashFunc=msrcryptoHashFunctions["sha-1"];var rsaObj=msrcryptoRsa(params.keyData,params.keyHandle.algorithm.name,hashFunc);var inKey=rsaObj.decrypt(encrypted_key);var additionalData=keyDataJwk.recipients[0].header.concat(".",keyDataJwk.recipients[0].encrypted_key,".",keyDataJwk.initialization_vector);var gcm=msrcryptoGcm(msrcryptoBlockCipher.aes(inKey));gcm.init(initialization_vector,utils.stringToBytes(additionalData),128);var result=gcm.decrypt(ciphertext,integrity_value);var keyObject=msrcryptoJwk.jwkToKey(result,params.algorithm,["k"]);return{type:"keyImport",keyData:keyObject.k,keyHandle:{algorithm:{name:params.algorithm.name},extractable:params.extractable||keyObject.extractable,keyUsage:params.keyUsage,type:"secret"}}}return{wrapKey:wrapKey,unwrapKey:unwrapKey}}();if(typeof operations!=="undefined"){operations.register("wrapKey","aes-gcm",msrcryptoWrapKey.wrapKey);operations.register("unwrapKey","aes-cbc",msrcryptoWrapKey.unwrapKey)}var publicMethods={subtle:msrcryptoSubtle,getRandomValues:function(array){var i;var randomValues=msrcryptoPseudoRandom.getBytes(array.length);for(i=0;i<array.length;i+=1){array[i]=randomValues[i]}return array},initPrng:function(entropyData){var entropyDataType=Object.prototype.toString.call(entropyData);if(entropyDataType!=="[object Array]"&&entropyDataType!=="[object Uint8Array]"){throw new Error("entropyData must be a Array or Uint8Array")}entropyPool&&entropyPool.reseed(entropyData);msrcryptoPseudoRandom.reseed(entropyPool.read(48));fprngEntropyProvided=true},toBase64:function(data,toBase64Url){return msrcryptoUtilities.toBase64(data,false)},base64ToString:function(base64String){return msrcryptoUtilities.base64ToString(base64String)},url:scriptUrl};if(typeof cryptoMath!=="undefined"){publicMethods.cryptoMath=cryptoMath}if(typeof testInterface!=="undefined"){publicMethods.testInterface=testInterface}var entropyPool;if(!runningInWorkerInstance){entropyPool=entropyPool||new MsrcryptoEntropy;entropyPool.init();var localEntropy=entropyPool.read(48);msrcryptoPseudoRandom.init(localEntropy)}return publicMethods}();if(nodeJsSupport){msrCrypto.version=msrCryptoVersion;module.exports=msrCrypto}
